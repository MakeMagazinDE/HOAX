; ##############################################################################
; ###########  KCPSM3 PicoBlaze Keyboard Scanner by cm 10/2010   ###############
; ###########            for Mediatronics pBlazIDE               ###############
; ##############################################################################

; Scan-Routine für HX3 mk3, Version für FATARSCAN2
; 26.03.2014 Kompletter Umbau für FPGA 23032014 und AVR-Firmware 3.5
; 06.09.2011 MIDI Thru gefixt
; 15.05.2011 Version für Nur-Midi-Empfang
; 23.03.2011 MIDI-Empfang OK, key_count-Ausgabe

c_splitpoint      EQU   24                        ; Bass-Split Untermanual, zählt ab key_scanned=0 (24 bei B200 oder 19 bis F#)
c_midi_minofs     EQU   2                         ; MIDI-On-Dynamik-Offset (empirisch ermittelt), 7 für Opto, 2 für Fatar Mx
c_corevers        EQU   $51                       ; $50=SR4014, $51=Fatar, $52=Opto, $53=MIDI RcvOnly
c_corerevi        EQU   $10                       ; Revisionsnummer

; mit Assemblierung DAT-Datei für XMODEM-Upload erstellen
                  MEM   "HX_fatar.mem"
                  EXEC  "mem2dat HX_FATAR"        ; neue mem2dat-Version mit Delphi erstellt!

; ##############################################################################
; ######################## Neue MPX-RAM-Organisation ###########################
; ##############################################################################

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

; ab hier geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014

; Ein/Ausschalten der HX3-Tastenkontakte erfolgt durch Schreiben der
; Kontaktdaten in ein Dual-Port-RAM, das sogerannte MPX-RAM.
; Jede Taste(nspalte) belegt eine Adresse,
; so dass das tiefste "C" immer Adresse 0 hat, das höchste "C" Adresse 60.
; Für jedes Manual stehen 8 Bits des 18-Bit-Datenbusses zur Verfügung,
; für das Pedal 2 (sonst ungenutzte Paritätsbits). Jeder Teil kann getrennt geschrieben/gelesen werden.

; MPX-RAM besteht aus 16 Pages je 64 Worte, 16 Bit plus zwei "Parity"-Bits,
; die hier für den Pedal-Status benutzt werden.

; Auswahl der Page über PB_PAGE.
; MSB, LSB und Parity-Bits können getrennt über STROBEs geschrieben werden.
; Page 0 dient direkt als Freigabe für Tastenkontakte:

; ##### LOWER #####  ##### UPPER #####  - Bytes
; 7 MSN 4   3 LSN 0  7 MSN 4   3 LSN 0  - Nibbles
; #NOISE#  #STEADY#  #NOISE#  #STEADY#
; - C B A   L C B A  - C B A   L C B A  - Bits
; mit ABC = Anzahl eingeschalteter Tastenkontakte, L = Level-Bit,

; Dabei wird Wert ABC jeweils anhand des folgenden Schemas dekodiert:
; 76543210 ; Busbar CONTACT-Bit 0 = 16'. Bit 7 schaltet sowohl 1' als auch 1 1/3' ein!
; 00000000 ; Stufe 0, alle aus
; 00100000 ; Stufe 1...
; 00100100
; 01100100
; 01100110
; 11100110
; 11101111
; 11111111 ; bis Stufe 7, alle an bzw. alle noisy
; Level-Bit L gelangt direkt zum CONTACT-Level-Bit 8.
; Ist STEADY komplett an, ist der Wert des Noise-Gates egal, da Werte verODERt werden.
; Pedalkontakt CONT_PEDAL ist an Bit(0) angeschlossen, Bit (1) kann als Scratch dienen.
; Die Nibbles können in pb_scanif.vhd einzeln gelesen werden!
; PAGE 1 als Soft-Timer für Tastenkontakte
; PAGE 2 als Soft-Timer für Noise
; PAGEs 6 bis 15 können nach Belieben verwendet werden.

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

; MPX RAM_PAGE Offsets
; Seitenaufteilung in 64-Byte-Seiten über RAM_PAGE
c_page_enables    EQU   0                         ; Direktes Lesen und Schreiben der Tastenkontakt-Werte

; Alle Timer starten bei Schreiben eines Wertes ungleich 0 und stoppen bei Erreichen von 255.
c_page_dyntimer   EQU   1                         ; Dynamik-Timer
c_page_noisetimer EQU   2                         ; Noise-Timer

c_page_state      EQU   3                         ; Flags
c_page_midiflags  EQU   4                         ; MIDI-sent-Flags
c_page_midirx     EQU   5                         ; MIDI-Empfangsdaten Dynamik für jede Taste
; 6..15 Scratch RAM

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
; Portadressen bidirektional

; $00 bis $07 Einzelbits SCANPORT Eingang, für Opto und Fatar
SCANPIO1          DSIO  0
SCANPIO2          DSIO  1
SCANPIO3          DSIO  2
SCANPIO4          DSIO  3
SCANPIO5          DSIO  4
SCANPIO6          DSIO  5
SCANPIO7          DSIO  6
SCANPIN8          DSIO  7

; $00 bis $07 Einzelbits AUXPORT Eingang, für OrganScan/HOAX5 mit 4014 und Bass13/25
AUXPIO1           DSIO  8
AUXPIO2           DSIO  9
AUXPIO3           DSIO  $0A
AUXPIO4           DSIO  $0B
AUXPIO5           DSIO  $0C
AUXPIO6           DSIO  $0D
AUXPIO7           DSIO  $0E
AUXPIN8           DSIO  $0F

SCANPIN           DSIN  $10                       ; Scan Port gesamt Leser
SCANPORT          DSOUT $10                       ; Scan Port gesamt Schreiben
SCANPORT_DDR      DSOUT $11                       ; Data Direction für Scan IF

AUXPIN            DSIN  $18                       ; Auxiliary Port gesamt
AUXPORT           DSOUT $18
AUXPORT_DDR       DSOUT $19                       ; Data Direction für Scan IF

; Output ports

c_strobe_mask     EQU   $20                       ; für indirektes Schreiben
UPPER_STROBE      DSOUT $20                       ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Upper (1 Byte)
LOWER_STROBE      DSOUT $21                       ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Lower (1 Byte)
PEDAL_STROBE      DSOUT $22                       ; Schreibzugriff erzeugt Write für Pedal-Bits (2 Bits)

MIDI_CMD          DSOUT $30                       ; MIDI-Befehl
MIDI_DB1          DSOUT $31
MIDI_DB2          DSOUT $32
MIDI_STR          DSOUT $33                       ; MIDI Strobe für AVR, neg. Flanke
STATUS            DSOUT $34                       ; STATUS an AVR SPI, Bit 0 bis 3 durch PB schreibbar, Bit 4 und 5 direkt SPI MIDI FIFO STAT
KEYS_PRESSED_UPR  DSOUT $35                       ; Bit 3..0: Upper, Bit 7..4: Lower
KEYS_PRESSED_LWR  DSOUT $36                       ; Bit 3..0: Upper, Bit 7..4: Lower

BASS_ENV          DSOUT $37                       ; Bass-Hüllkurve
BASS_BRIGHT       DSOUT $38                       ; Bit 0
PERC_ENV          DSOUT $39                       ; Percussion-Hüllkurve
MIDI_THRU_ON      DSOUT $3A                       ; Bit 0 schaltet MIDI_THRU_IN auf Ausgang
TWG_CONF_0        DSOUT $3B
TWG_CONF_1        DSOUT $3C

; Universal-Timer, hier für Scan-Durchlauf, 255 = 5,22 ms
; wird mit jedem SYNC alle 20,48 µs dekrementiert bis 0 erreicht
SCANTIMER_VAL     DSOUT $3D                       ; Schreiben des neuen Wertes startet Timer
SCANTIMER_ZERO    DSIN  $3E                       ; Flag wenn 0 erreicht

NOISE_FREQ        DSOUT $3F                       ; bestimmt Noise-Frequenz

RAM_PAGE          DSOUT $40                       ; Seitenadresse zum einfacheren Zugriff, Page 0 = MPX Dual Port
RAM_ADDR          DSOUT $41                       ; für alle Zugriffe gültig
RAM_WRDATA        DSOUT $42                       ; zu schreibende Daten

MIDI_TX           DSOUT 128                       ; MIDI UART-Tx-FIFO

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
; Input Ports

; Flags für SPI-Empfang:
; Bit 0 = Daten wurden geschrieben (wird durch Lesen der SPI-Register gelöscht)
; Bit 1 = AVR-MIDI FIFO Daten im Buffer,
; Bit 2 = AVR-MIDI FIFO Buffer halb voll
; Bit 3 = AVR-MIDI FIFO Buffer voll
SPI_FLAG          DSIN  $30                       ; "0000000" & spiflag
TX_STATUS         DSIN  $31                       ; Bit 0 = Buffer halbvoll, Bit 1 = Buffer voll

c_read_mask       EQU   $34                       ; für indirektes Lesen
RD_UPPER          DSIN  $34                       ; Upper-Byte vom MPX-RAM
RD_LOWER          DSIN  $35                       ; Lower-Byte vom MPX-RAM
RD_PEDAL          DSIN  $36                       ; Pedal-Bits vom MPX-RAM (1:0)

MIDI_IN1          DSIN  $38
MIDI_IN1_STATUS   DSIN  $39                       ; "0000" & midi1_full & midi1_half & midi1_datapresent & '0';
MIDI_IN2          DSIN  $3A
MIDI_IN2_STATUS   DSIN  $3B                       ; "0000" & midi2_full & midi2_half & midi2_datapresent & '0';
MIDI_AVR          DSIN  $3C                       ; MIDI vom AVR über SPI
MIDI_AVR_STATUS   DSIN  $3D                       ; "0000" & avrfifo_full & avrfifo_half & avrfifo_datapresent & avrmidiflag

RND_NUMBER        DSIN  $3F                       ; Zufallswert 8 Bit

; Werte vom AVR-SPI
SPI_MIDICH        DSIN  $24
SPI_MIDIOPT       DSIN  $25
SPI_SPLITMODE     DSIN  $26
SPI_SPLITON       DSIN  $27
SPI_SPLITPOINT    DSIN  $28                       ; NOCH NICHT BENUTZT
SPI_CLICKLEN      DSIN  $29
SPI_CONFIG_0      DSIN  $2A
SPI_CONFIG_1      DSIN  $2B
; SPI_AVR_MIDI      DSIN  $2C                      ; AVR-MIDI-Daten, FIFO-Eingang
SPI_TRANSPOSE     DSIN  $2D
SPI_PERCTIME      DSIN  $2E
SPI_PEDALTIME     DSIN  $2F

; Picoblaze Scratchpad Memory
s_splitpoint      EQU   0                         ; Tastennummer, selbst ermittelt
s_splitremap_upper EQU  2                         ; manual_select unterhalb Splitpunkt upper
s_splitremap_lower EQU  3                         ; manual_select unterhalb Splitpunkt lower

s_transpose       EQU   4

s_split_on        EQU   5                         ; Letzter Split-Zustand
s_splitmode_old   EQU   6

; 10..29 MIDI-Daten für Interpreter/Dispatcher
s_midi_cmd        EQU   10
s_midi_data1      EQU   11
s_midi_data2      EQU   12
s_midi_len        EQU   13
s_midi_cmd_masked EQU   14                        ; upper Nibble
s_midi_chan_masked EQU  15                        ; lower Nibble

; MIDI-Daten per Polling
s_midi1_cmd       EQU   16
s_midi1_data1     EQU   17
s_midi1_data2     EQU   18
s_midi1_len       EQU   19
s_midi1_counter   EQU   20

s_midi2_cmd       EQU   21
s_midi2_data1     EQU   22
s_midi2_data2     EQU   23
s_midi2_len       EQU   24
s_midi2_counter   EQU   25
; MIDI-Daten per Polling vom AVR
s_midi3_cmd       EQU   26
s_midi3_data1     EQU   27
s_midi3_data2     EQU   28
s_midi3_len       EQU   29
s_midi3_counter   EQU   30

s_midi_activesensing EQU 35                       ; Zähler/Timer für MIDI Active Sensing

; Pedal-Hüllkurve
s_pedal_lastkey   EQU   36
s_pedal_env_lsb   EQU   37
s_pedal_env_msb   EQU   38
s_pedal_on        EQU   39                        ; Bass-Flag Trigger für Hüllkurve

s_midich          EQU   40
s_midiopt         EQU   41
s_keycount_upper  EQU   42
s_keycount_lower  EQU   43

s_midi_localkey   EQU   50                        ; für local out, enthält aktuelle Taste einschließlich Offset
s_midi_localdyn   EQU   51

s_save_key_scanned EQU  52

s_loopcount       EQU   53                        ; ADC-Offset-Loopcount für Opto
s_lastkey_on      EQU   55                        ; letzte gedrückte Taste für Split
s_clicklen        EQU   57                        ; Timer-Startwert
s_clicklen_fast   EQU   58

; weitere Konstanten
c_maxkeys         EQU   61                        ; längste vorhandene Tastatur (44/49/61)
c_maxbasskeys     EQU   25                        ; Anzahl der Pedal-Tasten an AuxPort PL8
c_midikeyoffset   EQU   36                        ; Offset zu unterster MIDI-Note "C" bei 5 Oktaven (default 36)
c_scankey_delay   EQU   49                        ; Delay pro Taste für 1 ms Scandurchlauf in SYNC-Ticks (20,4 µs)
c_onclicklen      EQU   236                       ; NoiseTimer-Startwert, hierzu wird Wert von AVR (max. 15) addiert


; Register Renames
midi1_rxflag      EQU   sF
midi2_rxflag      EQU   sE
midi1_syscmdflag  EQU   sD
midi2_syscmdflag  EQU   sC
midi3_rxflag      EQU   sB

; häufig benutzte Variablen
page_select       EQU   sA                        ; Timer-Page c_page_xxx, 0..3=AutoInc-Timer, 4..15 = Scratch RAM
manual_select     EQU   s9                        ; aktuelles Manual, 0 = upper, 1 = lower, 2 = bass

key_matrix        EQU   s8                        ; für FATAR
group_matrix      EQU   s7

; Tastenzähler 0..60
key_scanned       EQU   s4                        ; aktuelle Taste, Zähler ab 0 bis Tastenanzahl
key_status        EQU   s3                        ; Zustand gedrückte Taste
; s0, s1, s2 als Universal-Akkus


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

cold_start: 
; Einsprungpunkt nach Laden des Scan Cores
                  DINT  
                  CALL  port_init
                  CALL  scan_init

main_loop: 
                  CALL  scan_config
                  CALL  scan_wait

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; +++++++++++++++++++++ Scanboard-spezifischer Teil ++++++++++++++++++++++++++++
; +++++++++++++++++++++        Hauptschleife        ++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; für FATAR
                  CALL  auxport_sr_load           ; SR-Daten Pedal übernehmen
                  CALL  fatar_groupreset          ; Reset 4024
                  CALL  fatar_keyreset            ; Reset 4017
                  LOAD  key_matrix, 0
                  LOAD  group_matrix, 0

key_loop: 
                  CALL  get_keystatus_upper
                  CALL  get_keystatus_lower
                  CALL  get_keystatus_pedal

                  ADD   key_scanned, 1            ; nächste Taste

                  CALL  auxport_clock             ; Pedal Puls für nächste Taste
                  CALL  fatar_keyclock            ; nächste Taste vorbereiten
                  ADD   key_matrix, 1
                  COMP  key_matrix, 8
                  JUMP  NZ, key_loop

                  CALL  midi_dispatch             ; MIDI-Daten empfangen?
                  LOAD  key_matrix, 0
                  CALL  fatar_keyreset            ; Reset 4017
                  CALL  fatar_groupclock
                  ADD   group_matrix, 1
                  COMP  group_matrix, 8           ; alle Tasten abgefragt?
                  JUMP  NZ, key_loop

                  JUMP  main_loop


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Hilfsroutinen: Zubehör für Scan-Routinen, Initialisierungen
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

port_init: 
                  LOAD  s0, $33                   ; für Fatar-/Opto-Interface
                  OUT   s0, SCANPORT_DDR
                  LOAD  s0, $03                   ; für Bass/Aux-Interface
                  OUT   s0, AUXPORT_DDR
                  RET   

clock_delay_long: 
                  LOAD  s0, 15
                  JUMP  clock_delay_loop
clock_delay:      LOAD  s0, 7
clock_delay_loop: 
                  SUB   s0, 1
                  JUMP  NZ, clock_delay_loop
                  RET   

clock_delay_short: 
                  LOAD  s0, 2
clock_delay_short_loop: 
                  SUB   s0, 1
                  JUMP  NZ, clock_delay_short_loop
clock_delay_veryshort: 
                  LOAD  s0, s0
                  RET   

auxport_clock: 
; pos. Impuls auf Auxport Pin 1
                  LOAD  s0, 1
                  OUT   s0, AUXPIO1               ; SR Clk
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, AUXPIO1
                  RET   

auxport_sr_load: 
; Parallele Daten der 4014-SR übernehmen
                  LOAD  s0, 1
                  OUT   s0, AUXPIO2               ; SR Data einlesen lassen
                  CALL  clock_delay
                  CALL  auxport_clock
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, AUXPIO2
                  RET   


; nur für Fatar-Tastatur benötigt

fatar_groupclock: 
; pos. Impuls auf Scanport Pin 1
                  LOAD  s0, 1
                  OUT   s0, SCANPIO1
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, SCANPIO1
; CALL      clock_delay
                  RET   

fatar_keyclock: 
; pos. Impuls auf Scanport Pin 1
                  LOAD  s0, 1
                  OUT   s0, SCANPIO5
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, SCANPIO5
                  RET   

fatar_groupreset: 
; pos. Impuls auf Scanport Pin 1
                  LOAD  s0, 1
                  OUT   s0, SCANPIO2
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, SCANPIO2
; CALL      clock_delay
                  RET   


fatar_keyreset: 
; pos. Impuls auf Scanport Pin 1
                  LOAD  s0, 1
                  OUT   s0, SCANPIO6
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, SCANPIO6
; CALL      clock_delay
                  RET   


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Tastenzustand aktuelle Taste ermitteln und behandeln
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


get_keystatus_upper: 
                  IN    s0, SCANPIO3              ; 1. Schließer
                  IN    s1, SCANPIO4              ; 2. Schließer
                  SL0   s1
                  OR    s0, s1
                  LOAD  key_status, s0
                  JUMP  set_key_upper

get_keystatus_lower: 
                  IN    s0, SCANPIO7              ; 1. Schließer
                  IN    s1, SCANPIN8              ; 2. Schließer
                  SL0   s1
                  OR    s0, s1
                  LOAD  key_status, s0
                  JUMP  set_key_lower

get_keystatus_pedal: 
                  IN    s0, AUXPIO5               ; bass
                  XOR   s0, 1                     ; ist jetzt 0 oder 1, keine Dynamik!
                  LOAD  key_status, s0
                  JUMP  set_key_pedal

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; +++++++++++++++++ Ende des Scanboard-spezifischen Teils ++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++





; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; +++++++++++++++++ Ab hier gleich für alle Scan-Routinen ++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



set_key_upper: 
; Einsprung von Scanplatinen-Abfrage
; wird direkt aus get_key aufgerufen, getrennt für upper und lower
; key_status enthält aktuelle Tastenzustand der Taste von manual_select
                  LOAD  manual_select, 0          ; 0 = UPPER
                  STORE key_scanned, s_midi_localkey; für MIDI local out

; in key_status ist jetzt aktueller eigener Tastenzustand. Ggf. MIDI senden
                  CALL  midi_local_manuals
; Daten von MIDI-IN
                  CALL  get_midircv               ; s0 enthält Dynamik-Wert der gescannten Taste
                  CALL  mididyn_to_s0             ; MIDI-Dynamik übersetzen
                  OR    key_status, s0
; key_status gesetzt, Tastenzustand und ggf. Split auswerten
                  CALL  set_key_upper_0
                  COMP  key_status, 0
                  RET   Z
                  STORE key_scanned, s_lastkey_on ; für Split merken
                  RET   

set_key_upper_0: 
                  LOAD  manual_select, 0          ; 0 = UPPER
                  COMP  key_scanned, 61           ; nur bis Note 60(+1) = C5
                  RET   NC
                  FETCH s0, s_splitpoint          ; ist ohne Split 0
                  COMP  key_scanned, s0
                  JUMP  NC, set_key_common        ; unterhalb Splitpoint?
                  FETCH manual_select, s_splitremap_upper; ggf. Remap

; LOAD  s1, $80           ; ##### TEST #####
; OUT   s1, AUXPORT       ; Trigger für LA
; OUT   manual_select, AUXPORT       ; ##### TEST #####
; OUT   s0, AUXPORT       ; Trigger für LA
; OUT   key_scanned, AUXPORT       ; Trigger für LA
; LOAD  s1, $00           ; ##### TEST #####
; OUT   s1, AUXPORT       ; Trigger für LA
                  JUMP  set_key_common

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

set_key_lower: 
; Einsprung von Scanplatinen-Abfrage
; wird direkt aus get_key aufgerufen, getrennt für upper und lower
; key_status enthält aktuelle Tastenzustand der Taste von manual_select
                  LOAD  manual_select, 1          ; 1 = LOWER
                  STORE key_scanned, s_midi_localkey; für MIDI local out

; in key_status ist jetzt aktueller eigener Tastenzustand. Ggf. MIDI senden
                  CALL  midi_local_manuals
; Daten von MIDI-IN
                  CALL  get_midircv               ; s0 enthält Dynamik-Wert der gescannten Taste
                  CALL  mididyn_to_s0             ; MIDI-Dynamik übersetzen in key_status
                  OR    key_status, s0
; key_status gesetzt, Tastenzustand und ggf. Split auswerten
                  CALL  set_key_lower_0
                  COMP  key_status, 0
                  RET   Z
                  STORE key_scanned, s_lastkey_on ; für Split merken
                  RET   

set_key_lower_0: 
                  LOAD  manual_select, 1          ; 1 = LOWER
                  COMP  key_scanned, 61           ; nur bis Note 60(+1) = C5
                  RET   NC
                  FETCH s0, s_splitpoint          ; ist ohne Split 0
                  COMP  key_scanned, s0
                  JUMP  NC, set_key_common        ; unterhalb Splitpoint?
                  FETCH manual_select, s_splitremap_lower; ggf. Remap
; JUMP      set_key_common

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

set_key_common: 
                  COMP  manual_select, 0
                  CALL  Z, inc_keys_upper
                  COMP  manual_select, 1
                  CALL  Z, inc_keys_lower
                  COMP  manual_select, 2
                  JUMP  Z, set_key_pedal_splitted ; keine Manual-Taste
                  COMP  key_status, 1
                  JUMP  Z, mpx_slow               ; nur 1. Kontakt, slow inc
                  COMP  key_status, 2
                  JUMP  Z, mpx_fast               ; nur 2. Kontakt
                  COMP  key_status, 3
                  JUMP  Z, mpx_fast               ; 1. und 2. Kontakt
                  JUMP  mpx_off                   ; sonst OFF

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

set_key_pedal: 
; Einsprung von Scanplatinen-Abfrage
; wird direkt aus get_keystatus_pedal aufgerufen, getrennt für Pedal
; Tastenzustand prüfen und verteilen
                  LOAD  manual_select, 2          ; 2 = PEDAL
                  COMP  key_scanned, c_maxbasskeys + 1
                  RET   NC                        ; wenn key_scanned > c_maxbasskeys
                  STORE key_scanned, s_midi_localkey; für MIDI local out
; in key_status ist jetzt aktueller eigener Tastenzustand. Ggf. MIDI senden
                  CALL  midi_local_pedal

                  FETCH s0, s_split_on
                  COMP  s0, 0
                  JUMP  Z, set_key_pedal_0        ; ist nicht gesplitted
                  FETCH s0, s_splitmode_old
                  COMP  s0, 1                     ; Lower to Upper
                  JUMP  Z, set_key_pedal_0        ; betrifft nicht Pedal
                  RET   

set_key_pedal_splitted: 
                  COMP  key_scanned, c_maxbasskeys + 1
                  RET   NC                        ; wenn key_scanned > c_maxbasskeys
set_key_pedal_0: 
; Daten von MIDI-IN. s0 enthält Dynamik-Wert der gescannten Taste
                  CALL  get_midircv
                  CALL  mididyn_to_s0             ; MIDI-Dynamik übersetzen in key_status
                  OR    key_status, s0
                  AND   key_status, 1

                  LOAD  manual_select, 2          ; 2 = Bass
                  COMP  key_scanned, c_maxbasskeys + 1
                  RET   NC                        ; wenn key_scanned > c_maxbasskeys
; JUMP      mpx_pedal

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; Tastenkontakte werden durch schreiben in das MPX-RAM eingeschaltet oder
; kurz auf "Noise" gesetzt.
; state-RAM enthalt Tastenzustand 0...15

mpx_pedal: 
; kleine Sonderbehandlung für Pedal, hat keine Dynamik und keine Noise-Bits:
; key_status enthält 0 (Taste aus) oder anderen Wert (Taste an),
; Falls sich neue Taste geändert hat, alte Taste löschen
; Vorher gespielte Pedaltaste löschen, Nummer der neue Pedaltaste merken
; manual_select enthält 2
                  FETCH s0, s_pedal_on            ; Speicher für gedrückte Taste
                  OR    s0, key_status
                  STORE s0, s_pedal_on            ; kann innerhalb Pedalschleife '1' werden
; get_state/set_state hier nicht benötigt, weil kein Noise berücksichtigt wird
                  COMP  key_status, 0
                  JUMP  NZ, mpx_pedal_1           ; wenn Taste an
                  FETCH s1, s_pedal_lastkey
                  COMP  s1, key_scanned
; nicht abschalten wenn letzte gespielte Note
                  LOAD  s0, key_status
                  JUMP  NZ, mpx_set_contacts_s0   ; Taste in key_scanned, Zustand in s0
mpx_pedal_1: 
                  LOAD  s0, 1
                  STORE key_scanned, s_pedal_lastkey; letzte eingeschaltete Pedalnote
                  JUMP  mpx_set_contacts_s0       ; Taste in key_scanned, Zustand in s0


mpx_off: 
; Taste ist aus. Check ob erstmals aus
                  CALL  get_state                 ; letzten Zustand holen
                  COMP  s0, 0
                  RET   Z                         ; ist bereits aus

                  CALL  reset_noisetimer
                  CALL  get_state                 ; letzten Zustand holen
                  AND   s0, 15                    ; Noise wegmaskieren
                  SL0   s0                        ; Zustand halbieren
                  AND   s0, 7                     ; halber Pegel
                  LOAD  s1, 0                     ; Noise aus
                  JUMP  mpx_set_contacts

mpx_fast: 
; Taste ist nicht offen
; zweiter Kontakt geschlossen, voll gedrückt, fast inc to max.
                  CALL  start_noisetimer_fast     ; starten, falls noch in Ruhe
                  JUMP  mpx_noise_timeout

mpx_slow: 
; Taste ist nicht offen
; nur erster Kontakt geschlossen
                  CALL  start_noisetimer          ; ggf starten; wenn laufend, Timer-Wert in s0
; JUMP  mpx_noise_timeout

mpx_noise_timeout: 
; CALL  get_noisetimer
                  COMP  s0, $FF                   ; Timer-Wert noch in s0
                  JUMP  Z, mpx_fullon             ; Klick beendet?
                  COMP  s0, $FD                   ; Timer-Wert noch in s0
                  JUMP  Z, mpx_halfon             ; 2 ms vor Ende halber Steady-Pegel

                  FETCH s1, s_clicklen_fast       ; Timer-Startwert
                  COMP  s0, s1                    ; s0 - s1
                  JUMP  NC, mpx_fullnoise

mpx_halfnoise: 
                  LOAD  s0, 0                     ; half level
                  LOAD  s1, 7
                  JUMP  mpx_set_contacts

mpx_fullnoise: 
                  LOAD  s0, 8                     ; full level
                  LOAD  s1, 7                     ; all noise
                  JUMP  mpx_set_contacts

mpx_halfon: 
                  LOAD  s0, 7
                  LOAD  s1, 0
                  JUMP  mpx_set_contacts

mpx_fullon: 
                  STORE key_scanned, s_lastkey_on ; für Split benötigt
                  LOAD  s0, 15                    ; full noise
                  LOAD  s1, 0
; jump  mpx_set_contacts

mpx_set_contacts: 
; Steady- (s0) und Noise-Anteil (s1) in mpx-RAM schreiben
; Tastennnummer in key_scanned
; Im Steady-Nibble s0: 0..7 Half Level, 8..15 Full Level (Bit 3)
; in ein Byte packen und zum MPX-RAM schicken
; in manual_select ist aktuell abgefragtes Manual
                  SL0   s1
                  SL0   s1
                  SL0   s1
                  SL0   s1
                  AND   s0, 15
                  OR    s0, s1
                  CALL  set_state
mpx_set_contacts_s0: 
; hier zu key_scanned ggf. Transponierwert addieren
; Tastennnummer in key_scanned, Zustand in s0
                  IN    s2, SPI_TRANSPOSE         ; hier als signed byte
                  ADD   s2, key_scanned
                  COMP  s2, 61
                  RET   NC
; separate Routine, um key_scanned nicht zu verändern
; (Transponierte) Note in s2
                  LOAD  page_select, c_page_enables
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page 0 = Tastenkontakte
                  OUT   s0, RAM_WRDATA            ; zu schreibende Daten in s0
                  OUT   s2, RAM_ADDR
                  LOAD  s1, manual_select         ; 0 oder 1
                  ADD   s1, c_strobe_mask
                  OUT   s0, ( s1 )                ; Upper oder Lower Strobe, $20 oder $21
                  RET   

; geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014

; Hilfsroutinen: Werte in Timer/Scratch-RAM lesen oder schreiben
; manual_select = 0 für Upper, manual_select = 1 für Lower Manual
start_noisetimer_fast: 
                  LOAD  page_select, c_page_noisetimer
                  CALL  get_ram
                  COMP  s0, 0
                  RET   NZ                        ; wenn bereits gestartet
                  IN    s0, RND_NUMBER            ; zufällige Länge
                  AND   s0, 1
                  FETCH s1, s_clicklen_fast       ; Timer-Startwert
                  JUMP  start_noisetimer_1

start_noisetimer: 
; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                  LOAD  page_select, c_page_noisetimer
                  CALL  get_ram
                  COMP  s0, 0
                  RET   NZ                        ; wenn bereits gestartet
                  IN    s0, RND_NUMBER            ; zufällige Länge
                  AND   s0, 3
                  FETCH s1, s_clicklen            ; Timer-Startwert
start_noisetimer_1: 
                  ADD   s0, s1
                  COMP  s0, $80                   ; auf Überlauf checken
                  JUMP  NC, set_noisetimer        ; wenn größer, gab es keinen Überlauf
                  LOAD  s0, $FE
set_noisetimer: 
                  LOAD  page_select, c_page_noisetimer
                  JUMP  set_ram

reset_noisetimer: 
                  LOAD  s0, 0
                  LOAD  page_select, c_page_noisetimer
                  JUMP  set_ram

get_noisetimer: 
                  LOAD  page_select, c_page_noisetimer
                  JUMP  get_ram

; ##############################################################################
; Dynamik- und Noise-Timer für beide Manuale aktualisieren
; geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014
; wird einmal pro Scan-Durchlauf aufgerufen, dauert ca. 52 µs
; ##############################################################################

update_timers: 
                  LOAD  page_select, c_page_dyntimer
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page Dynamik-Timer
                  LOAD  key_scanned, 0
                  CALL  update_timer_loop
                  LOAD  page_select, c_page_noisetimer
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page Noise-Timer
                  LOAD  key_scanned, 0

update_timer_loop: 
                  OUT   key_scanned, RAM_ADDR
                  ADD   key_scanned, 1
                  IN    s0, RD_UPPER
                  COMP  s0, 0
                  JUMP  Z, update_timer_done1     ; noch nicht gestartet
                  COMP  s0, 255
                  JUMP  Z, update_timer_done1     ; bereits abgelaufen
                  ADD   s0, 1
                  OUT   s0, RAM_WRDATA            ; zu schreibende Daten in s0
                  LOAD  s0, 0                     ; NOP
                  OUT   s0, UPPER_STROBE
                  LOAD  s0, 0                     ; NOP

update_timer_done1: 
                  IN    s0, RD_LOWER
                  COMP  s0, 0
                  JUMP  Z, update_timer_done2     ; noch nicht gestartet
                  COMP  s0, 255
                  JUMP  Z, update_timer_done2     ; bereits abgelaufen
                  ADD   s0, 1
                  OUT   s0, RAM_WRDATA            ; zu schreibende Daten in s0
                  LOAD  s0, 0                     ; NOP
                  OUT   s0, LOWER_STROBE

update_timer_done2: 
                  COMP  key_scanned, 64
                  JUMP  NZ, update_timer_loop
                  RET   

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

allnotesoff: 
; alle Töne, Flags und Timer löschen
                  LOAD  s0, 0
                  OUT   s0, RAM_WRDATA            ; Enables und Werte auf 0
                  OUT   s0, BASS_ENV
                  LOAD  key_scanned, 0
                  LOAD  page_select, 0
allnotesoff_loop: 
                  OUT   key_scanned, RAM_ADDR
                  OUT   page_select, RAM_PAGE
                  OUT   s0, UPPER_STROBE
                  OUT   s0, LOWER_STROBE
                  OUT   s0, PEDAL_STROBE

                  ADD   key_scanned, 1
                  COMP  key_scanned, 64           ; 64 Durchläufe?
                  JUMP  NZ, allnotesoff_loop
                  LOAD  key_scanned, 0
                  ADD   page_select, 1
                  COMP  page_select, 16           ; 16 Durchläufe?
                  JUMP  NZ, allnotesoff_loop
                  RET                             ; fertig

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

; Hüllkurvengenerator für Pedalsustain
; mit jedem Scan-Schleifendurchlauf alle 1 ms aktualisiert

pedal_envelope: 
; einmal vor jedem Scan-Durchlauf alle 1 ms aufgerufen
                  FETCH s0, s_pedal_env_msb
                  OUT   s0, BASS_ENV
                  IN    s1, SPI_PEDALTIME         ; 0..127
                  COMP  s1, 60                    ; Carry wird '1' wenn s1 kleiner 60
                  LOAD  s1, 0
                  SLA   s1                        ; shift carry in Bit 0
                  XOR   s1, 1
                  OUT   s1, BASS_BRIGHT

                  FETCH s0, s_pedal_on            ; Speicher für gedrückte Taste
                  COMP  s0, 0
                  JUMP  Z, pedal_envelope_dec
pedal_envelope_inc: 
; Pedal-Hüllkurve schnell 255 annähern
; s_pedal_env_msb enthält aktuellen Pedal-Pegel
                  FETCH s0, s_pedal_env_msb
                  COMP  s0, 255                   ; schon am Anschlag?
                  RET   Z
                  SL1   s0                        ; '1' einschieben, immer verdoppeln
                  STORE s0, s_pedal_env_msb
                  STORE s0, s_pedal_env_lsb
                  RET   

pedal_envelope_dec: 
; Pedal-Hüllkurve Null annähern
; s_pedal_env_msb enthält aktuellen Pedal-Pegel
                  COMP  s1, 1                     ; war noch BRIGHT-Switch
                  JUMP  Z, pedal_envelope_fastdec ; Original-Pedal ohne Sustain
                  FETCH s0, s_pedal_env_msb
                  COMP  s0, 0                     ; schon auf 0?
                  RET   Z
; Timer-Dekrement errechnen, semi-log. Abfall durch Einbeziehen des Zählerstands
                  IN    s1, SPI_PEDALTIME
                  SL0   s1                        ; 4..126
                  SL0   s1                        ; 8..252
                  SUB   s1, 8
                  SL0   s1
                  LOAD  s2, 0
                  SLA   s2                        ; Carry in s2 Bit 0
                  SR0   s0                        ; Level MSB, größer am Anfang, halber Wert
                  ADD   s1, s0                    ; 
                  ADDC  s2, 0

                  FETCH s0, s_pedal_env_lsb
                  SUB   s0, s1
                  STORE s0, s_pedal_env_lsb
                  FETCH s0, s_pedal_env_msb
                  SUBC  s0, s2
                  STORE s0, s_pedal_env_msb
                  JUMP  C, pedal_envelope_limit
                  RET   

pedal_envelope_limit: 
                  LOAD  s0, 0
                  STORE s0, s_pedal_env_lsb
                  STORE s0, s_pedal_env_msb
                  RET   

pedal_envelope_fastdec: 
                  FETCH s0, s_pedal_env_msb
                  COMP  s0, 0
                  RET   Z
                  SR0   s0                        ; '0' einschieben, immer halbieren
                  STORE s0, s_pedal_env_msb
                  STORE s0, s_pedal_env_lsb
                  RET   

; ##############################################################################
; ###################### NEUE MPX-ROUTINEN FÜR TIMER ###########################
; ##############################################################################


; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

start_dyntimer: 
; Dynamik-Timer der aktuellen Taste starten, wenn nicht bereits geschehen
                  LOAD  page_select, c_page_dyntimer
                  CALL  get_ram
                  COMP  s0, 0
                  RET   NZ                        ; wenn bereits gestartet
                  LOAD  s0, 1                     ; Timer starten, zählt aufwärts
                  JUMP  set_ram

reset_dyntimer: 
                  LOAD  s0, 0                     ; Timer stoppen
                  LOAD  page_select, c_page_dyntimer
                  JUMP  set_ram

get_dyntimer: 
                  LOAD  page_select, c_page_dyntimer
                  JUMP  get_ram

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

; Werte in MPX/Scratch-RAM setzen mit aktuellem manual_select und key_scanned

set_midiflag: 
                  LOAD  page_select, c_page_midiflags
                  JUMP  set_ram

set_state: 
                  LOAD  page_select, c_page_state
; JUMP  set_ram

set_ram: 
; zu schreibende Daten in s0, RAM_PAGE muss gesetzt sein
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page 0 = Tastenkontakte
                  OUT   s0, RAM_WRDATA            ; zu schreibende Daten in s0
                  OUT   key_scanned, RAM_ADDR
                  LOAD  s1, manual_select         ; 0 oder 1
                  ADD   s1, c_strobe_mask
                  OUT   s0, ( s1 )                ; Upper oder Lower Strobe, $20 oder $21
                  RET   

get_midircv: 
                  LOAD  page_select, c_page_midirx
                  JUMP  get_ram

get_midiflag: 
                  LOAD  page_select, c_page_midiflags
                  JUMP  get_ram

get_state: 
                  LOAD  page_select, c_page_state
; JUMP  get_ram

get_ram: 
; gelesene Daten später in s0
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page 0 = Tastenkontakte
                  OUT   key_scanned, RAM_ADDR
                  LOAD  s1, manual_select         ; 0 oder 1
                  ADD   s1, c_read_mask
                  IN    s0, ( s1 )                ; Upper, Lower oder Pedal Read
                  RET                             ; gelesene Daten in s0

; bis hier geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014

; ##############################################################################

; MIDI-Routinen für Scan-Events bei Keyboard-Abfrage
; sollte bei allen Scan-Boards gleich sein
midi_local_manuals: 
                  COMP  key_status, 0
                  JUMP  Z, midi_local_off
                  COMP  key_status, 1
                  JUMP  Z, midi_local_start       ; MIDI Dyn-Timer dieser Taste starten, sofern noch nicht geschehen
                  COMP  key_status, 2             ; verschmutzter Kontakt?
                  JUMP  Z, midi_local_on_nodyn    ; dann Sonderbehandlung
                  JUMP  midi_local_on

midi_local_pedal: 
                  COMP  key_status, 0
                  JUMP  Z, midi_local_off
                  JUMP  midi_local_on_nodyn

midi_local_start: 
                  CALL  get_midiflag              ; bereits gesendet? Dann nichts machen
                  COMP  s0, $00
                  RET   NZ                        ; schon passiert
; MIDI Timer dieser Taste starten, sofern noch nicht geschehen
                  CALL  start_dyntimer
; in s0 ist vom Vergleich noch der vorherige Wert des Dyn-Timers oder 1
                  COMP  s0, $FF                   ; Dynamik-Timer evt. schon abgelaufen, dh. 255?
                  RET   NZ                        ; wenn noch nicht abgelaufen, zurück
; Timer ist abgelaufen, evt. 2. Schließer schmutzig oder Taste sehr langsam gedrückt
                  LOAD  s1, $01                   ; minimale Dynamik vorbereiten
                  JUMP  midi_local_on_s1          ; und weiter mit Dynamik in s1

midi_local_on_nodyn: 
; Taste 1. Kontakt schmutzig. Mittlere Dynamik senden, falls nicht schon geschehen
                  CALL  get_midiflag              ; bereits gesendet? Dann nichts machen
                  COMP  s0, $00
                  RET   NZ                        ; schon passiert
                  LOAD  s1, $40                   ; mittlere Dynamik vorbereiten
                  JUMP  midi_local_on_s1          ; und weiter mit Dynamik in s1

midi_local_on: 
; MIDI-Check - muss ON gesendet werden?
                  CALL  get_midiflag              ; bereits gesendet? Dann nichts machen
                  COMP  s0, $00
                  RET   NZ                        ; schon passiert

; Dynamik-Kurve mit zwei Steigungen, ab $C0 Eingangswert doppelt so steil
                  CALL  get_dyntimer              ; Dynamik-Timer 1..255
                  LOAD  s1, $FF
                  SUB   s1, s0                    ; (255 - Timerstand) in s1
                  COMP  s1, $C0
                  JUMP  NC, midi_local_on_scale1
                  SR0   s1                        ; /2 -> 0..127
                  SR0   s1                        ; /2 -> 0..127
                  COMP  s1, $02
                  JUMP  NC, midi_local_on_scale0  ; wenn kleiner $02
                  LOAD  s1, $02                   ; minimaler MIDI-dyn-Wert
midi_local_on_scale0: 
                  JUMP  midi_local_on_scaled
midi_local_on_scale1: 
                  LOAD  s0, s1
                  SR0   s1                        ; /2 -> 0..127
                  SR0   s1                        ; /2 -> 0..127
                  SUB   s0, $C0
                  ADD   s1, s0
; Da während eines Schleifendurchlaufs der DynTimer weiterläuft und immer einen
; Mindestwert erreicht, wird hier ein kleiner Offset hinzuaddiert.
; Durch Ausprobieren bei schnellstem Tastenanschlag ermittelt, so dass
; beim Dynamik-Byte Maximalwert $7F knapp erreicht wird.
midi_local_on_scaled: 
                  ADD   s1, c_midi_minofs
                  COMP  s1, $7F
                  JUMP  C, midi_local_on_s1       ; wenn kleiner $7F
                  LOAD  s1, $7F

midi_local_on_s1: 
                  STORE s1, s_midi_localdyn
                  LOAD  s0, $01
                  CALL  set_midiflag              ; Flag: ON ist gesendet
                  JUMP  midi_local_out

midi_local_off: 
; MIDI-Check - muss OFF gesendet werden?
                  CALL  get_midiflag              ; bereits gesendet? Dann nichts machen
                  COMP  s0, 0
                  RET   Z                         ; OFF ist bereits gesendet
                  CALL  reset_dyntimer
                  LOAD  s0, $00
                  STORE s0, s_midi_localdyn
                  CALL  set_midiflag              ; Flag: OFF ist gesendet
; JUMP      midi_local_out                ; und senden

; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge'	// MIDI Option 2
; 'RcvSndMgNoCC'	// MIDI Option 3

midi_local_out: 
; Manual in manual_select, On/Off-Dynamik in s_midi_localdyn
                  FETCH s0, s_midiopt
                  COMP  s0, 0                     ; nur senden, wenn nicht Thru
                  RET   Z
                  CALL  midi_waitbuf
                  FETCH s0, s_midich              ; eingestellter Kanal
                  LOAD  s1, manual_select         ; Manual-Nummer addieren
                  ADD   s0, s1
                  OR    s0, $90
                  OUT   s0, MIDI_TX
                  FETCH s0, s_midi_localkey
                  ADD   s0, c_midikeyoffset
                  AND   s0, $7F
                  OUT   s0, MIDI_TX
                  FETCH s0, s_midi_localdyn       ; gemessene Dynamik
                  OUT   s0, MIDI_TX
                  RET   

midi_waitbuf: 
                  IN    s0, TX_STATUS             ; half full?
                  AND   s0, 1
                  COMP  s0, 1
                  JUMP  Z, midi_waitbuf           ; auf Buffer-Leerung warten
                  RET   

midi_activesensing: 
                  FETCH s0, s_midiopt
                  COMP  s0, 0                     ; nur senden, wenn nicht Thru
                  RET   Z
                  CALL  midi_waitbuf
                  LOAD  s0, $FE
                  OUT   s0, MIDI_TX
                  RET   

; ##############################################################################
; MIDI-Subroutinen für MIDI-Empfang
; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge',	// MIDI Option 2
; 'RcvSndMgNoCC'	// MIDI Option 3
; ##############################################################################


mididyn_to_s0: 
; für upper, lower und bass: s0 je nach Dynamik setzen auf 1 oder 3
                  COMP  s0, 0                     ; MIDI-Taste aus, nichts machen?
                  RET   Z
                  COMP  s0, $41                   ; Dynamikschwelle
                  JUMP  C, mididyn_to_keystatus_slow; springe wenn <$41
                  LOAD  s0, 3
                  RET   
mididyn_to_keystatus_slow: 
                  LOAD  s0, 1
                  RET   

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

midi_dispatch: 
; Dispatcher stellt fest, ob und was es zu tun gibt
; wird regelmäßig aus Hauptschleife aufgerufen
midi_dispatch_1: 
                  CALL  midi1_receive
                  COMP  midi1_rxflag, 0
                  JUMP  Z, midi_dispatch_2        ; wenn kein Flag gesetzt
                  LOAD  midi1_rxflag, 0           ; Rx-Flag löschen

; LOAD  s1, $FF                   ; ##### TEST #####
; OUT   s1, AUXPORT               ; Trigger für LA
; LOAD  s0, 0                     ; Daten
; OUT   s0, AUXPORT               ; ##### TEST #####

                  FETCH s0, s_midi1_cmd           ; von IRQ gesetzte Bytes
; OUT   s0, AUXPORT               ; ##### TEST #####
                  STORE s0, s_midi_cmd
                  FETCH s0, s_midi1_data1
; OUT   s0, AUXPORT               ; ##### TEST #####
                  STORE s0, s_midi_data1
                  FETCH s0, s_midi1_data2
; OUT   s0, AUXPORT               ; ##### TEST #####
                  STORE s0, s_midi_data2
                  FETCH s0, s_midi1_len
; OUT   s0, AUXPORT               ; ##### TEST #####
                  STORE s0, s_midi_len
                  CALL  midi_dispatch_all

midi_dispatch_2: 
; Daten vom zweiten MIDI-Eingang
                  CALL  midi2_receive
                  COMP  midi2_rxflag, 0
                  JUMP  Z, midi_dispatch_3        ; wenn kein Flag gesetzt
                  LOAD  midi2_rxflag, 0           ; Rx-Flag löschen
                  FETCH s0, s_midi2_cmd           ; von IRQ gesetzte Bytes
                  STORE s0, s_midi_cmd
                  FETCH s0, s_midi2_data1
                  STORE s0, s_midi_data1
                  FETCH s0, s_midi2_data2
                  STORE s0, s_midi_data2
                  FETCH s0, s_midi2_len
                  STORE s0, s_midi_len
                  CALL  midi_dispatch_all

midi_dispatch_3: 
; empfangenen Datensatz 1 bis 3 Bytes vom AVR senden
                  FETCH s0, s_midiopt
                  COMP  s0, 0                     ; nur senden, wenn nicht Thru
                  RET   Z
                  CALL  midi3_receive
                  COMP  midi3_rxflag, 0
                  RET   Z                         ; wenn kein Flag gesetzt
                  LOAD  midi3_rxflag, 0           ; Rx-Flag löschen
                  CALL  midi_waitbuf
                  FETCH s0, s_midi3_cmd
                  OUT   s0, MIDI_TX
                  FETCH s0, s_midi3_len
                  COMP  s0, 0
                  RET   Z
                  FETCH s0, s_midi3_data1
                  OUT   s0, MIDI_TX
                  FETCH s0, s_midi3_len
                  COMP  s0, 1
                  RET   Z
                  FETCH s0, s_midi3_data2
                  OUT   s0, MIDI_TX
                  RET   

midi_dispatch_all: 
; MIDI-Datensatz vollständig, dekodieren und Taste beschreiben
                  FETCH s0, s_midi_cmd
                  AND   s0, $0F                   ; Kanal isolieren
                  STORE s0, s_midi_chan_masked
                  FETCH s0, s_midi_cmd
                  AND   s0, $F0                   ; Befehl isolieren
                  STORE s0, s_midi_cmd_masked

                  LOAD  manual_select, 0          ; Default
                  FETCH s1, s_midi_chan_masked
                  FETCH s0, s_midich              ; eingestellter Kanal
                  COMP  s1, s0                    ; eingestellter gleich empfangener Kanal?
                  JUMP  Z, midi_dispatch_onoff    ; mit manual_select = 0, upper
                  ADD   s0, 1
                  COMP  s1, s0                    ; eingestellter Kanal +1?
                  JUMP  Z, midi_dispatch_onoff_lower
                  ADD   s0, 1
                  COMP  s1, s0                    ; eingestellter Kanal +2?
                  RET   NZ                        ; Kanal nicht für uns, verwerfen

midi_dispatch_onoff_pedal: 
; MIDI-NoteOn/NoteOff-Befehle
                  LOAD  manual_select, 2
                  FETCH s0, s_midi_data2          ; Dynamik dieser Taste
                  COMP  s0, 0                     ; default Dynamik 0
                  JUMP  Z, midi_dispatch_onoff
                  LOAD  s0, 1                     ; Tastendynamik 1 statt irgendwas
                  STORE s0, s_midi_data2          ; Dynamik dieser Taste
                  JUMP  midi_dispatch_onoff       ; nur einbittig speichern!

midi_dispatch_onoff_lower: 
; MIDI-NoteOn/NoteOff-Befehle
                  LOAD  manual_select, 1
; JUMP  midi_dispatch_onoff

midi_dispatch_onoff: 
; MIDI-NoteOn/NoteOff-Befehle, Dynamik bereits in s2, Manual in manual_select
                  FETCH s0, s_midi_cmd_masked
                  COMP  s0, $90
                  JUMP  Z, midi_dispatch_set_ram
                  COMP  s0, $80
                  JUMP  NZ, midi_dispatch_rest    ; wenn kein ON/OFF
                  LOAD  s0, 0                     ; MIDI-Befehl Taste OFF, Dynamik 0
                  STORE s0, s_midi_data2          ; Dynamik dieser Taste

midi_dispatch_set_ram: 
; jetzt Notenwert und Dynamik abspeichern
; Dynamik ist 0 bei Key-Off-Befehl
                  FETCH s1, s_midi_data1          ; MIDI-Key in s1
                  SUB   s1, c_midikeyoffset       ; Tastennummer ermitteln
                  COMP  s1, 61
                  RET   NC                        ; nicht schreiben, ist außerhalb 5 Okt.
                  FETCH s0, s_midi_data2          ; Dynamik dieser Taste
                  OUT   s0, RAM_WRDATA            ; zu schreibende Dynamik in s2
                  OUT   s1, RAM_ADDR              ; Tastennummer in s1
                  LOAD  s0, c_page_midirx
                  OUT   s0, RAM_PAGE              ; MPX-RAM Page
                  LOAD  s0, manual_select         ; 0 oder 1
                  ADD   s0, c_strobe_mask
                  OUT   s0, ( s0 )                ; Upper, Lower oder Pedal Strobe
                  RET   

midi_dispatch_rest: 
; Program Change und Controller? Dann an AVR
                  COMP  s0, $C0
                  JUMP  Z, midi_pchange
                  COMP  s0, $B0
                  RET   NZ                        ; alles andere unberücksichtigt
midi_cchange: 
; bei Controller Change auf ALL NOTES OFF prüfen, dann weiter wie Program Change
                  FETCH s0, s_midi_data1
                  COMP  s0, 123                   ; All Notes OFF?
; JUMP      Z, allnotesoff_manual      ; falls nicht, weiter mit AVR-IRQ

midi_pchange: 
; auf Program Change hin nur einen AVR-IRQ auslösen; MIDI-Daten an SPI
                  FETCH s0, s_midi_cmd
                  OUT   s0, MIDI_CMD
                  FETCH s0, s_midi_data1
                  OUT   s0, MIDI_DB1
                  FETCH s0, s_midi_data2
                  OUT   s0, MIDI_DB2
                  LOAD  s0, 1                     ; pos. Flanke an MIDI-FIFO
                  OUT   s0, MIDI_STR
                  LOAD  s0, 0
                  OUT   s0, MIDI_STR
                  RET   

allnotesoff_manual: 
; feststellen, für welchen Kanal gesendet und alle Tasten löschen
allnotesoff_upper: 
; noch nicht implementiert
                  RET   
allnotesoff_lower: 
; noch nicht implementiert
                  RET   
allnotesoff_pedal: 
; noch nicht implementiert
                  RET   

scan_init: 
                  LOAD  s0, c_corevers
                  OUT   s0, MIDI_DB2
                  LOAD  s0, c_corerevi
                  OUT   s0, MIDI_DB1
                  LOAD  s0, $AA
                  OUT   s0, MIDI_CMD
                  LOAD  s0, 1                     ; pos. Flanke an MIDI-FIFO
                  OUT   s0, MIDI_STR
                  LOAD  s0, 0
                  OUT   s0, MIDI_STR
                  OUT   s0, SCANPORT
                  OUT   s0, STATUS
                  OUT   s0, MIDI_THRU_ON

                  CALL  allnotesoff
                  LOAD  s0, 63
                  STORE s0, s_pedal_lastkey
                  LOAD  s0, 0
                  OUT   s0, MIDI_STR
                  OUT   s0, RAM_PAGE
                  STORE s0, s_pedal_env_msb
                  STORE s0, s_pedal_env_lsb
                  STORE s0, s_pedal_lastkey
                  STORE s0, s_keycount_upper      ; Anzahl gedrückter Tasten
                  STORE s0, s_keycount_lower
                  STORE s0, s_transpose
                  IN    s0, SPI_SPLITMODE
                  STORE s0, s_splitmode_old
                  LOAD  s0, c_splitpoint
                  STORE s0, s_splitpoint
                  CALL  split_off

                  LOAD  midi1_rxflag, 0
                  LOAD  midi1_syscmdflag, 0
                  LOAD  midi2_rxflag, 0
                  LOAD  midi2_syscmdflag, 0
                  LOAD  midi3_rxflag, 0
                  RET   

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

scan_config: 
                  FETCH s0, s_keycount_upper      ; Anzahl gedrückter Tasten
                  OUT   s0, KEYS_PRESSED_UPR
                  FETCH s0, s_keycount_lower      ; Anzahl gedrückter Tasten
                  OUT   s0, KEYS_PRESSED_LWR

                  IN    s0, SPI_CONFIG_0
                  OUT   s0, TWG_CONF_0
                  IN    s0, SPI_CONFIG_1
                  OUT   s0, TWG_CONF_1

                  IN    s0, SPI_TRANSPOSE
                  FETCH s1, s_transpose
                  COMP  s0, s1
                  STORE s0, s_transpose
                  CALL  NZ, allnotesoff

                  IN    s1, SPI_CLICKLEN
                  AND   s1, 15                    ; max. 15 ms
                  LOAD  s0, 255
                  SUB   s0, s1
                  STORE s0, s_clicklen            ; Startwert 1ms-Timer
                  SR0   s1
                  SR0   s1
                  ADD   s0, s1
                  STORE s0, s_clicklen_fast

                  IN    s0, SPI_CLICKLEN
                  AND   s0, $F0
                  SR0   s0
                  SR0   s0                        ; Wert immer noch vervierfacht
; z.B. $13(5A) = Teilfaktor 4954 für 10 kHz Samples oder 5 kHz Noise-Frequenz
                  OUT   s0, NOISE_FREQ

                  IN    s0, SPI_MIDICH
                  AND   s0, $0F
                  STORE s0, s_midich
; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge'	// MIDI Option 2
; 'RcvSndMgNoCC'	// MIDI Option 3
                  IN    s0, SPI_MIDIOPT
                  AND   s0, $03
                  STORE s0, s_midiopt
                  COMP  s0, 0
                  LOAD  s0, 0
                  JUMP  NZ, is_not_thru
                  LOAD  s0, 1
is_not_thru: 
                  OUT   s0, MIDI_THRU_ON

; Split überprüfen. In s0 befindet sich ggf. neue Split-ON/OFF-Einstellung vom Panel

                  FETCH s0, s_split_on            ; alter Split-On-Zustand
                  IN    s1, SPI_SPLITON           ; neu von Bedienelement
                  AND   s1, 1
                  COMP  s0, s1
                  STORE s1, s_split_on
                  CALL  NZ, set_splitpoint        ; wenn Split nicht geändert, beibehalten
                  RET   

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

scan_wait: 
; auf Scan-Freigabe durch Timer warten, Active Sensing senden
                  CALL  midi_dispatch             ; MIDI-Daten empfangen?
                  IN    s0, SCANTIMER_ZERO        ; auf Scan-Freigabe warten
                  COMP  s0, 0
                  JUMP  Z, scan_wait
                  LOAD  s0, c_scankey_delay       ; Scan-Timer neu laden
                  OUT   s0, SCANTIMER_VAL

; alle Timer updaten - einmal pro Scan-Durchlauf, dauert ca. 52 µs
                  CALL  update_timers
                  CALL  pedal_envelope            ; Neuberechnung aktueller Sustain-Pegel

                  FETCH s0, s_midi_activesensing  ; nach 256 ms Active Sensing senden
                  ADD   s0, 1
                  STORE s0, s_midi_activesensing
                  COMP  s0, 0
                  CALL  Z, midi_activesensing

                  LOAD  key_scanned, 0            ; Start mit Taste 0
                  STORE key_scanned, s_keycount_upper
                  STORE key_scanned, s_keycount_lower
                  STORE key_scanned, s_pedal_on   ; Speicher für gedrückte Taste
                  RET   

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

inc_keys_upper: 
; bei gedrückter Taste Anzahl erhöhen
                  COMP  key_status, 0
                  RET   Z
                  FETCH s0, s_keycount_upper      ; gedrückte Tasten zählen
                  ADD   s0, $01
                  STORE s0, s_keycount_upper
                  RET   

inc_keys_lower: 
; bei gedrückter Taste Anzahl erhöhen
                  COMP  key_status, 0
                  RET   Z
                  FETCH s0, s_keycount_lower      ; gedrückte Tasten zählen
                  ADD   s0, $01
                  STORE s0, s_keycount_lower
                  RET   

; ##############################################################################
; Splitmode setzen:
; 0 = PedalToLower,
; 1 = LowerToUpper und
; 2 = PedalToUpper
; ##############################################################################

set_splitpoint: 
; Split-Funktion wurde seit letztem Durchlauf von OFF auf ON geändert.
                  CALL  allnotesoff

                  FETCH s0, s_split_on
                  COMP  s0, 0
                  JUMP  Z, split_off

; Feststellen, ob Keyboard-Tasten gedrückt wurden, dann diese als
; Splitpoint nehmen. Falls keine gedrückt, letzten Split
                  FETCH s0, s_keycount_upper
                  FETCH s1, s_keycount_lower
                  OR    s0, s1
                  COMP  s0, 0
                  JUMP  NZ, split_custom          ; Tasten gedrückt, neuer Splitmode

; gedrückte Taste als Splitpoint. Springt danach zu split_on
; wenn gar keine Keyboard-Taste gedrückt, weiter mit alten Werten, sofern initialisiert
                  JUMP  split_restore_old

split_custom: 
                  FETCH s1, s_lastkey_on
                  STORE s1, s_splitpoint
                  FETCH s0, s_keycount_upper
                  COMP  s0, 0
                  JUMP  Z, split_pedal_to_lower   ; Upper 0? Dann Split auf Lower
                  COMP  s0, 1                     ; Nur eine Taste gedrückt? Dann Lower to Upper
                  JUMP  Z, split_lower_to_upper   ; Wenn nur eine Taste, Lower to Upper
                  LOAD  s0, 2                     ; Mehr als eine Taste, Bass to Upper
                  JUMP  split_pedal_to_upper

split_restore_old: 
; 0 = PedalToLower, 1 = LowerToUpper und  2 = PedalToUpper
                  FETCH s0, s_splitmode_old
                  COMP  s0, 1
                  JUMP  Z, split_lower_to_upper
                  COMP  s0, 2
                  JUMP  Z, split_pedal_to_upper
; JUMP  split_pedal_to_lower           ; wenn 0

; Wenn bei der Tastenabfrage key_scanned < Splitpoint,
; wird manual_select auf s_splitremap gesetzt
split_pedal_to_lower:                             ; split_mode 0
                  STORE s0, s_splitmode_old
                  LOAD  s0, 2                     ; Pedal
                  STORE s0, s_splitremap_lower
                  LOAD  s0, 0                     ; Upper
                  STORE s0, s_splitremap_upper
                  RET   
split_lower_to_upper:                             ; split_mode 1
                  STORE s0, s_splitmode_old
                  LOAD  s0, 2
                  STORE s0, s_splitremap_lower
                  LOAD  s0, 1
                  STORE s0, s_splitremap_upper
                  RET   
split_pedal_to_upper:                             ; split_mode 2
                  STORE s0, s_splitmode_old
                  LOAD  s0, 1
                  STORE s0, s_splitremap_lower
                  LOAD  s0, 2
                  STORE s0, s_splitremap_upper
                  RET   
split_off: 
                  LOAD  s0, 1
                  STORE s0, s_splitremap_lower
                  LOAD  s0, 0
                  STORE s0, s_splitremap_upper
                  RET   

midi1_receive: 
; MIDI Daten wurden von Input 1 empfangen
; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge'	,	// MIDI Option 2
; 'RcvSndMgNoCC'		// MIDI Option 3
                  IN    s0, MIDI_IN1_STATUS
                  COMP  s0, 0                     ; Daten empfangen?
                  RET   Z

; LOAD  s1, $F8           ; ##### TEST #####
; OUT   s1, AUXPORT       ; Trigger für LA
; OUT   s0, AUXPORT       ; ##### TEST #####

                  IN    s0, MIDI_IN1
                  COMP  s0, $FE                   ; Active Sensing verwerfen, kann immer kommen
                  RET   Z
                  COMP  s0, $F0                   ; Sysex usw. ab $F0 verwerfen
                  JUMP  NC, midi1_is_syscontrol

                  TEST  s0, 128
                  JUMP  Z, midi1_is_databyte
                  LOAD  midi1_syscmdflag, $00     ; ist kein Active Sensing usw.
                  LOAD  s1, 0                     ; ist ein neuer (Running) Status
                  STORE s1, s_midi1_counter
                  STORE s0, s_midi1_cmd
                  RET   
midi1_is_databyte: 
                  COMP  midi1_syscmdflag, $00
                  RET   NZ
                  FETCH s1, s_midi1_counter
                  ADD   s1, 1
                  STORE s1, s_midi1_counter
                  COMP  s1, 2
                  JUMP  Z, midi1_is_second_databyte
; erstes Datenbyte empfangen:
; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
; Datensatz ist mit einem Datenbyte vollständig!
                  FETCH s1, s_midi1_cmd
                  AND   s1, $F0                   ; Kanal ausmaskieren
                  COMP  s1, $C0                   ; program change
                  JUMP  Z, midi1_is_singledatabyte
                  COMP  s1, $D0                   ; channel pressure
                  JUMP  Z, midi1_is_singledatabyte

midi1_is_first_databyte: 
                  STORE s0, s_midi1_data1
                  RET   
; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
midi1_is_singledatabyte: 
                  STORE s0, s_midi1_data1
midi1_is_second_databyte: 
                  STORE s0, s_midi1_data2
                  FETCH s1, s_midi1_counter
                  STORE s1, s_midi1_len           ; letzte Anzahl empfangener Datenbytes
                  LOAD  s1, 0                     ; Datensatz vollständig
                  STORE s1, s_midi1_counter       ; neue Anzahl empfangener Datenbytes
                  LOAD  midi1_rxflag, $FF         ; jetzt vollständig, Flag setzen
                  RET   
midi1_is_syscontrol: 
                  LOAD  midi1_syscmdflag, $FF
                  RET   

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

midi2_receive: 
; MIDI Daten wurden von Input 2 empfangen
; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge'	,	// MIDI Option 2
; 'RcvSndMgNoCC'		// MIDI Option 3
                  IN    s0, MIDI_IN2_STATUS
                  COMP  s0, 0                     ; Daten empfangen?
                  RET   Z

; LOAD  s1, $F9           ; ##### TEST #####
; OUT   s1, AUXPORT       ; Trigger für LA
; OUT   s0, AUXPORT       ; ##### TEST #####

                  IN    s0, MIDI_IN2
                  COMP  s0, $FE                   ; Active Sensing verwerfen, kann immer kommen
                  RET   Z
                  COMP  s0, $F0                   ; Sysex usw. ab $F0 verwerfen
                  JUMP  NC, midi2_is_syscontrol

                  TEST  s0, 128
                  JUMP  Z, midi2_is_databyte
                  LOAD  midi2_syscmdflag, $00     ; ist kein Active Sensing usw.
                  LOAD  s1, 0                     ; ist ein neuer (Running) Status
                  STORE s1, s_midi2_counter
                  STORE s0, s_midi2_cmd
                  RET   
midi2_is_databyte: 
                  COMP  midi2_syscmdflag, $00
                  RET   NZ
                  FETCH s1, s_midi2_counter
                  ADD   s1, 1
                  STORE s1, s_midi2_counter
                  COMP  s1, 2
                  JUMP  Z, midi2_is_second_databyte
; erstes Datenbyte empfangen:
; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
; Datensatz ist mit einem Datenbyte vollständig!
                  FETCH s1, s_midi2_cmd
                  AND   s1, $F0                   ; Kanal ausmaskieren
                  COMP  s1, $C0                   ; program change
                  JUMP  Z, midi2_is_singledatabyte
                  COMP  s1, $D0                   ; channel pressure
                  JUMP  Z, midi2_is_singledatabyte

midi2_is_first_databyte: 
                  STORE s0, s_midi2_data1
                  RET   
; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
midi2_is_singledatabyte: 
                  STORE s0, s_midi2_data1
midi2_is_second_databyte: 
                  STORE s0, s_midi2_data2
                  FETCH s1, s_midi2_counter
                  STORE s1, s_midi2_len           ; Anzahl empfangener Datenbytes
                  LOAD  s1, 0                     ; Datensatz vollständig
                  STORE s1, s_midi2_counter       ; letzte Anzahl empfangener Datenbytes
                  LOAD  midi2_rxflag, $FF         ; jetzt vollständig, Flag setzen
                  RET   
midi2_is_syscontrol: 
                  LOAD  midi2_syscmdflag, $FF
                  RET   

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

midi3_receive: 
; MIDI Daten wurden von AVR empfangen
; vereinfachte Version ohne SysEx-Behandlung
                  IN    s0, MIDI_AVR_STATUS
                  AND   s0, $0E
                  COMP  s0, 0                     ; Daten empfangen?
                  RET   Z

                  LOAD  s1, $FA                   ; ##### TEST #####
                  OUT   s1, AUXPORT               ; Trigger für LA
                  OUT   s0, AUXPORT               ; ##### TEST #####
                  IN    s0, MIDI_AVR
midi3_is_not_thru: 
                  TEST  s0, 128
                  JUMP  Z, midi3_is_databyte
                  LOAD  s1, 0                     ; ist ein neuer (Running) Status
                  STORE s1, s_midi3_counter
                  STORE s0, s_midi3_cmd
                  RET   
midi3_is_databyte: 
                  FETCH s1, s_midi3_counter
                  ADD   s1, 1
                  STORE s1, s_midi3_counter
                  COMP  s1, 2
                  JUMP  Z, midi3_is_second_databyte
; erstes Datenbyte empfangen:
; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
; Datensatz ist mit einem Datenbyte vollständig!
                  FETCH s1, s_midi3_cmd
                  AND   s1, $F0                   ; Kanal ausmaskieren
                  COMP  s1, $C0                   ; program change
                  JUMP  Z, midi3_is_singledatabyte
                  COMP  s1, $D0                   ; channel pressure
                  JUMP  Z, midi3_is_singledatabyte

midi3_is_first_databyte: 
                  STORE s0, s_midi3_data1
                  RET   
; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
midi3_is_singledatabyte: 
                  STORE s0, s_midi3_data1
midi3_is_second_databyte: 
                  STORE s0, s_midi3_data2
                  FETCH s1, s_midi3_counter
                  STORE s1, s_midi3_len           ; Anzahl empfangener Datenbytes
                  LOAD  s1, 0                     ; Datensatz vollständig
                  STORE s1, s_midi3_counter       ; letzte Anzahl empfangener Datenbytes
                  LOAD  midi3_rxflag, $FF         ; jetzt vollständig, Flag setzen
                  RET   


any_IRQ: 
; IRQ ausgelöst durch kcuart
                  RETI  DISABLE

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


                  ORG   $3FF
                  JUMP  any_IRQ

