; ##############################################################################
; ###########  KCPSM3 PicoBlaze Keyboard Scanner by cm 10/2010   ###############
; ###########            for Mediatronics pBlazIDE               ###############
; ##############################################################################

; Scan-Routine für HX3 mk3, Version für FATARSCAN2
; 26.03.2014 Kompletter Umbau für FPGA 23032014 und AVR-Firmware 3.5
; 06.09.2011 MIDI Thru gefixt
; 15.05.2011 Version für Nur-Midi-Empfang
; 23.03.2011 MIDI-Empfang OK, key_count-Ausgabe

; Je nach Tastaturumfang sind anzupassen:
; c_upperoffset       EQU       0                 ; Offset Keyscan wenn Obermanual (12="C", 17="F")
; c_loweroffset       EQU       0                 ; Offset Keyscan wenn Untermanual (0="C", 5="F")
c_pedaloffset     EQU   0                         ; addiert zu key_scanned wenn Basspedal (0="C")
c_splitpoint      EQU   24                        ; Bass-Split Untermanual, zählt ab key_scanned=0 (24 bei B200 oder 19 bis F#)
c_midi_minofs     EQU   2                         ; MIDI-On-Dynamik-Offset (empirisch ermittelt), 7 für Opto, 2 für Fatar Mx
c_corevers        EQU   $51                       ; $50=SR4014, $51=Fatar, $52=Opto, $53=MIDI RcvOnly
c_corerevi        EQU   $0D                       ; Revisionsnummer

; Tastenzähler key_scanned läuft von 0 bis c_maxkeys
; key_mpx ist tatsächlich erzeugte Note
; Tastenwerte werden in ein Block-RAM für den Multiplexer geschrieben
; mit getrennten Bits für NOISE und ENABLE.
; Alle Timer starten bei Schreiben eines Wertes ungleich 0 und stoppen bei Erreichen von 255.

; mit Assemblierung DAT-Datei für XMODEM-Upload erstellen
                  MEM   "HX_fatar.mem"
                  EXEC  "mem2dat HX_fatar"        ; neue mem2dat-Version mit Delphi erstellt!

; ##############################################################################
; ######################## Neue MPX-RAM-Organisation ###########################
; ##############################################################################

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

; ab hier geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014

; Ein/Ausschalten der HX3-Tastenkontakte erfolgt durch Schreiben der
; Kontaktdaten in ein Dual-Port-RAM, das sogerannte MPX-RAM.
; Jede Taste(nspalte) belegt eine Adresse,
; so dass das tiefste "C" immer Adresse 0 hat, das höchste "C" Adresse 60.
; Für jedes Manual stehen 8 Bits des 18-Bit-Datenbusses zur Verfügung,
; für das Pedal 2 (sonst ungenutzte Paritätsbits). Jeder Teil kann getrennt geschrieben/gelesen werden.

; MPX-RAM besteht aus 16 Pages je 64 Worte, 16 Bit plus zwei "Parity"-Bits,
; die hier für den Pedal-Status benutzt werden.

; Auswahl der Page über PB_PAGE.
; MSB, LSB und Parity-Bits können getrennt über STROBEs geschrieben werden.
; Page 0 dient direkt als Freigabe für Tastenkontakte:

; ##### LOWER #####  ##### UPPER #####  - Bytes
; 7 MSN 4   3 LSN 0  7 MSN 4   3 LSN 0  - Nibbles
; #NOISE#  #STEADY#  #NOISE#  #STEADY#
; - C B A   L C B A  - C B A   L C B A  - Bits
; mit ABC = Anzahl eingeschalteter Tastenkontakte, L = Level-Bit,

; Dabei wird Wert ABC jeweils anhand des folgenden Schemas dekodiert:
; 76543210 ; Busbar CONTACT-Bit 0 = 16'. Bit 7 schaltet sowohl 1' als auch 1 1/3' ein!
; 00000000 ; Stufe 0, alle aus
; 00100000 ; Stufe 1...
; 00100100
; 01100100
; 01100110
; 11100110
; 11101111
; 11111111 ; bis Stufe 7, alle an bzw. alle noisy
; Level-Bit L gelangt direkt zum CONTACT-Level-Bit 8.
; Ist STEADY komplett an, ist der Wert des Noise-Gates egal, da Werte verODERt werden.
; Pedalkontakt CONT_PEDAL ist an Bit(0) angeschlossen, Bit (1) kann als Scratch dienen.
; Die Nibbles können in pb_scanif.vhd einzeln gelesen werden!
; PAGE 1 als Soft-Timer für Tastenkontakte
; PAGE 2 als Soft-Timer für Noise
; PAGEs 6 bis 15 können nach Belieben verwendet werden.

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

; MPX RAM_PAGE Offsets
; Seitenaufteilung in 64-Byte-Seiten über RAM_PAGE
c_page_enables    EQU   0                         ; Direktes Lesen und Schreiben der Tastenkontakt-Werte

; Alle Timer starten bei Schreiben eines Wertes ungleich 0 und stoppen bei Erreichen von 255.
c_page_dyntimer   EQU   1                         ; Dynamik-Timer
c_page_noisetimer EQU   2                         ; Noise-Timer

c_page_state      EQU   3                         ; Flags
c_page_midiflags  EQU   4                         ; MIDI-sent-Flags
c_page_midirx     EQU   5                         ; MIDI-Empfangsdaten Dynamik für jede Taste
; 6..15 Scratch RAM

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
; Portadressen bidirektional

; $00 bis $07 Einzelbits SCANPORT Eingang, für Opto und Fatar
SCANPIO1          DSIO  0
SCANPIO2          DSIO  1
SCANPIO3          DSIO  2
SCANPIO4          DSIO  3
SCANPIO5          DSIO  4
SCANPIO6          DSIO  5
SCANPIO7          DSIO  6
SCANPIN8          DSIO  7

; $00 bis $07 Einzelbits AUXPORT Eingang, für OrganScan/HOAX5 mit 4014 und Bass13/25
AUXPIO1           DSIO  8
AUXPIO2           DSIO  9
AUXPIO3           DSIO  $0A
AUXPIO4           DSIO  $0B
AUXPIO5           DSIO  $0C
AUXPIO6           DSIO  $0D
AUXPIO7           DSIO  $0E
AUXPIN8           DSIO  $0F

SCANPIN           DSIN  $10                       ; Scan Port gesamt Leser
SCANPORT          DSOUT $10                       ; Scan Port gesamt Schreiben
SCANPORT_DDR      DSOUT $11                       ; Data Direction für Scan IF

AUXPIN            DSIN  $18                       ; Auxiliary Port gesamt
AUXPORT           DSOUT $18
AUXPORT_DDR       DSOUT $19                       ; Data Direction für Scan IF

; Output ports

c_strobe_mask     EQU   $20                       ; für indirektes Schreiben
UPPER_STROBE      DSOUT $20                       ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Upper (1 Byte)
LOWER_STROBE      DSOUT $21                       ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Lower (1 Byte)
PEDAL_STROBE      DSOUT $22                       ; Schreibzugriff erzeugt Write für Pedal-Bits (2 Bits)

MIDI_CMD          DSOUT $30                       ; MIDI-Befehl
MIDI_DB1          DSOUT $31
MIDI_DB2          DSOUT $32
MIDI_STR          DSOUT $33                       ; MIDI Strobe für AVR, neg. Flanke
STATUS            DSOUT $34                       ; STATUS an AVR SPI, Bit 0 bis 3 durch PB schreibbar, Bit 4 und 5 direkt SPI MIDI FIFO STAT
KEYS_PRESSED_UPR  DSOUT $35                       ; Bit 3..0: Upper, Bit 7..4: Lower
KEYS_PRESSED_LWR  DSOUT $36                       ; Bit 3..0: Upper, Bit 7..4: Lower

BASS_ENV          DSOUT $37                       ; Bass-Hüllkurve
BASS_BRIGHT       DSOUT $38                       ; Bit 0
PERC_ENV          DSOUT $39                       ; Percussion-Hüllkurve
MIDI_THRU_ON      DSOUT $3A                       ; Bit 0 schaltet MIDI_THRU_IN auf Ausgang
TWG_CONF_0        DSOUT $3B
TWG_CONF_1        DSOUT $3C

; Universal-Timer, hier für Scan-Durchlauf, 255 = 5,22 ms
; wird mit jedem SYNC alle 20,48 µs dekrementiert bis 0 erreicht
SCANTIMER_VAL     DSOUT $3D                       ; Schreiben des neuen Wertes startet Timer
SCANTIMER_ZERO    DSIN  $3E                       ; Flag wenn 0 erreicht

NOISE_FREQ        DSOUT $3F                       ; bestimmt Noise-Frequenz

RAM_PAGE          DSOUT $40                       ; Seitenadresse zum einfacheren Zugriff, Page 0 = MPX Dual Port
RAM_ADDR          DSOUT $41                       ; für alle Zugriffe gültig
RAM_WRDATA        DSOUT $42                       ; zu schreibende Daten

MIDI_TX           DSOUT 128                       ; MIDI UART-Tx-FIFO

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
; Input Ports

MIDI_RX           DSIN  $30                       ; Empfangsdaten über IRQ
TX_STATUS         DSIN  $31                       ; Bit 0 = Buffer halbvoll, Bit 1 = Buffer voll
; Flags für SPI-Empfang:
; Bit 0 = Daten wurden geschrieben (wird durch Lesen der SPI-Register gelöscht)
; Bit 1 = AVR-MIDI Daten im Buffer,
; Bit 2 = AVR-MIDI Buffer halb voll
; Bit 3 = AVR-MIDI Buffer voll
SPI_FLAGS         DSIN  $33                       ; "0000" & fifo_full & fifo_half & fifo_datapresent & spiflag

c_read_mask       EQU   $34                       ; für indirektes Lesen
RD_UPPER          DSIN  $34                       ; Upper-Byte vom MPX-RAM
RD_LOWER          DSIN  $35                       ; Lower-Byte vom MPX-RAM
RD_PEDAL          DSIN  $36                       ; Pedal-Bits vom MPX-RAM (1:0)
SPI_FLAG_CLR      DSIN  $3D                       ; Lesen dieser Adressen setzt SPI_FLAGS Bit 0 zurück
RND_NUMBER        DSIN  $3F                       ; Zufallswert 8 Bit

; Werte vom AVR-SPI
SPI_MIDICH        DSIN  $24
SPI_MIDIOPT       DSIN  $25
SPI_SPLITMODE     DSIN  $26
SPI_SPLITON       DSIN  $27
SPI_SPLITPOINT    DSIN  $28                       ; NOCH NICHT BENUTZT
SPI_CLICKLEN      DSIN  $29
SPI_CONFIG_0      DSIN  $2A
SPI_CONFIG_1      DSIN  $2B
SPI_AVR_MIDI      DSIN  $2C                       ; AVR-MIDI-FIFO, Lesen stellt nächstes Byte bereit.
SPI_TRANSPOSE     DSIN  $2D
SPI_PERCTIME      DSIN  $2E
SPI_PEDALTIME     DSIN  $2F

; Picoblaze Scratchpad Memory
s_splitpoint      EQU   0                         ; Tastennummer, selbst ermittelt
s_splitremap_upper EQU  2                         ; manual_select unterhalb Splitpunkt upper
s_splitremap_lower EQU  3                         ; manual_select unterhalb Splitpunkt lower

s_transpose       EQU   4

s_split_on        EQU   8                         ; Letzter Split-Zustand
s_splitmode_old   EQU   11

s_midi_cmd        EQU   20
s_midi_byte1      EQU   21
s_midi_byte2      EQU   22
s_midi_count      EQU   23
s_midi_cmd_masked EQU   24                        ; upper Nibble

; MIDI-Daten per IRQ
s_midi_irq_cmd    EQU   32
s_midi_irq_byte1  EQU   33
s_midi_irq_byte2  EQU   34
s_midi_irq_count  EQU   35

s_pedal_lastkey   EQU   36
s_pedal_env_lsb   EQU   37
s_pedal_env_msb   EQU   38
s_pedal_on        EQU   39                        ; Bass-Flag Trigger für Hüllkurve

s_midich          EQU   40
s_midiopt         EQU   41
s_keycount_upper  EQU   42
s_keycount_lower  EQU   43

s_midi_localkey   EQU   50                        ; für local out, enthält aktuelle Taste einschließlich Offset
s_midi_localdyn   EQU   51

s_save_key_scanned EQU  52

s_loopcount       EQU   53                        ; ADC-Offset-Loopcount für Opto
s_lastkey_on      EQU   55                        ; letzte gedrückte Taste für Split
s_midi_activesensing EQU 56                       ; Zähler/Timer für MIDI Active Sensing
s_clicklen        EQU   57                        ; Timer-Startwert
s_clicklen_fast   EQU   58

; weitere Konstanten
c_maxkeys         EQU   61                        ; längste vorhandene Tastatur (44/49/61)
c_maxbasskeys     EQU   25                        ; Anzahl der Pedal-Tasten an AuxPort PL8
c_midikeyoffset   EQU   36                        ; Offset zu unterster MIDI-Note "C" bei 5 Oktaven (default 36)
c_scankey_delay   EQU   49                        ; Delay pro Taste für 1 ms Scandurchlauf in SYNC-Ticks (20,4 µs)
c_onclicklen      EQU   236                       ; NoiseTimer-Startwert, hierzu wird Wert von AVR (max. 15) addiert


; Register Renames
i_rxflag          EQU   sF                        ; i_* nur im IRQ benutzt
i_datacount       EQU   sE
i_acc0            EQU   sD
i_acc1            EQU   sC
i_syscmdflag      EQU   sB

; häufig benutzte Variablen
page_select       EQU   sA                        ; Timer-Page c_page_xxx, 0..3=AutoInc-Timer, 4..15 = Scratch RAM
manual_select     EQU   s9                        ; aktuelles Manual, 0 = upper, 1 = lower, 2 = bass

key_matrix        EQU   s8
group_matrix      EQU   s7
key_count         EQU   s6

; Tastenzähler 0..60
key_mpx           EQU   s5                        ; momentaner Tastenwert zur MPX-Kontakt-Page
key_scanned       EQU   s4                        ; aktuelle Taste, Zähler ab 0 bis Tastenanzahl
key_status        EQU   s3                        ; Zustand gedrückte Taste
; s0, s1, s2 als Universal-Akkus


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

cold_start: 
; Einsprungpunkt nach Laden des Scan Cores
                  DINT  
                  CALL  port_init
                  LOAD  s0, c_corevers
                  OUT   s0, MIDI_DB2
                  LOAD  s0, c_corerevi
                  OUT   s0, MIDI_DB1
                  LOAD  s0, $AA
                  OUT   s0, MIDI_CMD
                  LOAD  s0, 1                     ; pos. Flanke an MIDI-FIFO
                  OUT   s0, MIDI_STR
                  LOAD  s0, 0
                  OUT   s0, MIDI_STR
                  OUT   s0, SCANPORT
                  OUT   s0, STATUS
                  OUT   s0, MIDI_THRU_ON

                  CALL  allnotesoff
                  LOAD  s0, 63
                  STORE s0, s_pedal_lastkey
                  LOAD  s0, 0
                  OUT   s0, MIDI_STR
                  OUT   s0, RAM_PAGE
                  STORE s0, s_pedal_env_msb
                  STORE s0, s_pedal_env_lsb
                  STORE s0, s_pedal_lastkey
                  STORE s0, s_transpose
                  IN    s0, SPI_SPLITMODE
                  STORE s0, s_splitmode_old
                  LOAD  s0, c_splitpoint
                  STORE s0, s_splitpoint
                  CALL  split_off

                  LOAD  i_datacount, 0
                  LOAD  i_rxflag, 0
                  LOAD  i_syscmdflag, 0

                  CALL  shift_sr_empty            ; Schieberegister einmal leerschieben

                  EINT  

main_loop: 
                  IN    s0, SPI_CONFIG_0
                  OUT   s0, TWG_CONF_0
                  IN    s0, SPI_CONFIG_1
                  OUT   s0, TWG_CONF_1

                  IN    s0, SPI_TRANSPOSE
                  FETCH s1, s_transpose
                  COMP  s0, s1
                  STORE s0, s_transpose
                  CALL  NZ, allnotesoff

                  IN    s1, SPI_CLICKLEN
                  AND   s1, 15                    ; max. 15 ms
                  LOAD  s0, 255
                  SUB   s0, s1
                  STORE s0, s_clicklen            ; Startwert 1ms-Timer
                  SR0   s1
                  SR0   s1
                  ADD   s0, s1
                  STORE s0, s_clicklen_fast

                  IN    s0, SPI_CLICKLEN
                  AND   s0, $F0
                  SR0   s0
                  SR0   s0                        ; Wert immer noch vervierfacht
; z.B. $13(5A) = Teilfaktor 4954 für 10 kHz Samples oder 5 kHz Noise-Frequenz
                  OUT   s0, NOISE_FREQ

                  IN    s0, SPI_MIDICH
                  AND   s0, $0F
                  STORE s0, s_midich
; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge'	// MIDI Option 2
; 'RcvSndMgNoCC'	// MIDI Option 3
                  IN    s0, SPI_MIDIOPT
                  AND   s0, $03
                  STORE s0, s_midiopt

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; Split überprüfen. In s0 befindet sich ggf. neue Split-ON/OFF-Einstellung vom Panel

                  FETCH s0, s_split_on            ; alter Split-On-Zustand
                  IN    s1, SPI_SPLITON           ; neu von Bedienelement
                  AND   s1, 1
                  COMP  s0, s1
                  STORE s1, s_split_on
                  CALL  NZ, set_splitpoint        ; wenn Split nicht geändert, beibehalten



; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; +++++++++++++++++++++ Scanboard-spezifischer Teil ++++++++++++++++++++++++++++
; +++++++++++++++++++++        Hauptschleife        ++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; Hauptschleife für MIDI input. Keine eigenen Tasten abfragen
main_loop_short: 
                  CALL  midi_dispatch             ; MIDI-Daten empfangen?
                  IN    s0, SCANTIMER_ZERO        ; auf Scan-Freigabe warten
                  COMP  s0, 0
                  JUMP  Z, main_loop_short
                  LOAD  s0, c_scankey_delay       ; Scan-Timer neu laden
                  OUT   s0, SCANTIMER_VAL

; alle Timer updaten - einmal pro Scan-Durchlauf, dauert ca. 52 µs
                  CALL  update_timers

; call perc_envelope
                  CALL  pedal_envelope            ; Neuberechnung aktueller Sustain-Pegel
                  FETCH s0, s_midi_activesensing  ; nach 256 ms Active Sensing senden
                  ADD   s0, 1
                  STORE s0, s_midi_activesensing
                  COMP  s0, 0
                  CALL  Z, midi_activesensing

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; beide Manuale und Pedal abfragen
                  CALL  auxport_sr_load           ; SR-Daten Pedal übernehmen
                  CALL  fatar_groupreset          ; Reset 4024
                  CALL  fatar_keyreset            ; Reset 4017
                  LOAD  key_matrix, 0
                  LOAD  group_matrix, 0

                  LOAD  key_scanned, 0            ; Start mit Taste 0
                  STORE key_scanned, s_keycount_upper
                  STORE key_scanned, s_keycount_lower
                  STORE key_scanned, s_pedal_on   ; Speicher für gedrückte Taste

key_loop: 
                  CALL  midi_dispatch             ; MIDI-Daten empfangen?
                  CALL  get_keystatus_upper
                  CALL  get_keystatus_lower
                  CALL  get_keystatus_pedal       ; Tastenzustand holen

                  CALL  auxport_clock             ; Pedal Puls für nächste Taste
                  CALL  fatar_keyclock            ; nächste Taste vorbereiten

                  ADD   key_scanned, 1            ; nächste Taste

                  ADD   key_matrix, 1
                  COMP  key_matrix, 8
                  JUMP  NZ, key_loop
                  LOAD  key_matrix, 0
                  CALL  fatar_keyreset            ; Reset 4017
                  CALL  fatar_groupclock
                  ADD   group_matrix, 1
                  COMP  group_matrix, 8           ; alle Tasten abgefragt?
                  JUMP  NZ, key_loop

; COMP  key_scanned, c_maxkeys    ; alle Tasten abgefragt?
; JUMP  NZ, key_loop

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                  FETCH s0, s_keycount_upper      ; Anzahl gedrückter Tasten
                  OUT   s0, KEYS_PRESSED_UPR
                  FETCH s0, s_keycount_lower      ; Anzahl gedrückter Tasten
                  OUT   s0, KEYS_PRESSED_LWR

                  IN    s1, SPI_FLAGS
                  TEST  s1, 2                     ; SPI MIDI received Flag
                  JUMP  Z, main_loop              ; wenn 0,  wurde nichts empfangen

; fordert nächstes Byte vom FIFO an:
                  IN    s0, SPI_AVR_MIDI
                  TEST  s1, 2                     ; New Data Present Flag
                  CALL  C, midi_dispatch_avr      ; mit SPI_FLAGS in s1 und Daten in s0
                  JUMP  main_loop

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Hilfsroutinen: Zubehör für Scan-Routinen, Initialisierungen
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


port_init: 
                  LOAD  s0, $33                   ; für Fatar-/Opto-Interface
                  OUT   s0, SCANPORT_DDR
                  LOAD  s0, $03                   ; für Bass/Aux-Interface
                  OUT   s0, AUXPORT_DDR
                  RET   

shift_sr_empty: 
                  LOAD  key_scanned, 0
                  CALL  auxport_sr_load
shift_sr_empty_loop: 
                  CALL  auxport_clock
                  CALL  clock_delay
                  ADD   key_scanned, 1            ; nächste Taste
                  COMP  key_scanned, c_maxkeys    ; alle Tasten abgefragt?
                  JUMP  NZ, shift_sr_empty_loop
                  RET   

clock_delay_long: 
                  LOAD  s0, 15
                  JUMP  clock_delay_loop
clock_delay:      LOAD  s0, 7
clock_delay_loop: 
                  SUB   s0, 1
                  JUMP  NZ, clock_delay_loop
                  RET   

clock_delay_short: 
                  LOAD  s0, 2
clock_delay_short_loop: 
                  SUB   s0, 1
                  JUMP  NZ, clock_delay_short_loop
clock_delay_veryshort: 
                  LOAD  s0, s0
                  RET   

auxport_clock: 
; pos. Impuls auf Auxport Pin 1
                  LOAD  s0, 1
                  OUT   s0, AUXPIO1               ; SR Clk
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, AUXPIO1
                  RET   

auxport_sr_load: 
; Parallele Daten der 4014-SR übernehmen
                  LOAD  s0, 1
                  OUT   s0, AUXPIO2               ; SR Data einlesen lassen
                  CALL  clock_delay
                  CALL  auxport_clock
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, AUXPIO2
                  CALL  clock_delay_long
                  RET   


; nur für Fatar-Tastatur benötigt

fatar_groupclock: 
; pos. Impuls auf Scanport Pin 1
                  LOAD  s0, 1
                  OUT   s0, SCANPIO1
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, SCANPIO1
; CALL      clock_delay
                  RET   

fatar_keyclock: 
; pos. Impuls auf Scanport Pin 1
                  LOAD  s0, 1
                  OUT   s0, SCANPIO5
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, SCANPIO5
                  RET   

fatar_groupreset: 
; pos. Impuls auf Scanport Pin 1
                  LOAD  s0, 1
                  OUT   s0, SCANPIO2
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, SCANPIO2
; CALL      clock_delay
                  RET   


fatar_keyreset: 
; pos. Impuls auf Scanport Pin 1
                  LOAD  s0, 1
                  OUT   s0, SCANPIO6
                  CALL  clock_delay
                  LOAD  s0, 0
                  OUT   s0, SCANPIO6
; CALL      clock_delay
                  RET   


; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Tastenzustand aktuelle Taste ermitteln
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


; hier MIDI, deshalb KEINE Scan-Platinen an AUXPORT oder SCANPORT

; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge',	// MIDI Option 2
; 'RcvSndMgNoCC'	// MIDI Option 3

get_keystatus_upper: 
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                  CALL  clock_delay               ; settle delay, notwendig!
                  IN    s0, SCANPIO3              ; 1. Schließer
                  IN    s1, SCANPIO4              ; 2. Schließer
                  SL0   s1
                  OR    s0, s1
                  LOAD  key_status, s0
                  LOAD  key_mpx, key_scanned      ; Ton gleich gescannter Taste
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                  LOAD  manual_select, 0          ; 0 = UPPER
                  STORE key_mpx, s_midi_localkey  ; für MIDI local out

; in key_status ist jetzt aktueller eigener Tastenzustand. Ggf. MIDI senden
                  CALL  midi_local_manuals
; Daten von MIDI-IN
                  CALL  get_midircv               ; s0 enthält Dynamik-Wert der gescannten Taste
                  CALL  mididyn_to_keystatus      ; MIDI-Dynamik übersetzen
                  OR    key_status, s0
; key_status gesetzt, Tastenzustand und ggf. Split auswerten
                  CALL  set_key_upper
                  COMP  key_status, 0
                  RET   Z
                  STORE key_mpx, s_lastkey_on     ; für Split merken
                  RET   

get_keystatus_lower: 
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                  IN    s0, SCANPIO7              ; 1. Schließer
                  IN    s1, SCANPIN8              ; 2. Schließer
                  SL0   s1
                  OR    s0, s1
                  LOAD  key_status, s0
                  LOAD  key_mpx, key_scanned      ; gleich gescannter Taste
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                  LOAD  manual_select, 1          ; 1 = LOWER
                  STORE key_mpx, s_midi_localkey  ; für MIDI local out

; in key_status ist jetzt aktueller eigener Tastenzustand. Ggf. MIDI senden
                  CALL  midi_local_manuals
; Daten von MIDI-IN
                  CALL  get_midircv               ; s0 enthält Dynamik-Wert der gescannten Taste
                  CALL  mididyn_to_keystatus      ; MIDI-Dynamik übersetzen in key_status
                  OR    key_status, s0
; key_status gesetzt, Tastenzustand und ggf. Split auswerten
                  CALL  set_key_lower
                  COMP  key_status, 0
                  RET   Z
                  STORE key_mpx, s_lastkey_on     ; für Split merken
                  RET   

get_keystatus_pedal: 
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                  IN    s0, AUXPIO5               ; bass
                  XOR   s0, 1                     ; ist jetzt 0 oder 1, keine Dynamik!
                  LOAD  key_status, s0
                  LOAD  key_mpx, key_scanned      ; gleich gescannter Taste
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                  LOAD  manual_select, 2          ; 2 = PEDAL
                  COMP  key_mpx, c_maxbasskeys + 1
                  RET   NC                        ; wenn key_scanned > c_maxbasskeys

                  STORE key_mpx, s_midi_localkey  ; für MIDI local out
; in key_status ist jetzt aktueller eigener Tastenzustand. Ggf. MIDI senden
                  CALL  midi_local_pedal
; Daten von MIDI-IN. s0 enthält Dynamik-Wert der gescannten Taste
                  CALL  get_midircv
                  CALL  mididyn_to_keystatus      ; MIDI-Dynamik übersetzen in key_status
                  OR    key_status, s0
                  AND   key_status, 1
                  JUMP  set_key_pedal

mididyn_to_keystatus: 
; für upper, lower und bass: s0 je nach Dynamik setzen auf 1 oder 3
                  COMP  s0, 0                     ; MIDI-Taste aus, nichts machen?
                  RET   Z
                  COMP  s0, $41                   ; Dynamikschwelle
                  JUMP  C, mididyn_to_keystatus_slow; springe wenn <$41
                  LOAD  s0, 3
                  RET   
mididyn_to_keystatus_slow: 
                  LOAD  s0, 1
                  RET   

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; +++++++++++++++++ Ende des Scanboard-spezifischen Teils ++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

inc_keys_upper: 
; bei gedrückter Taste Anzahl erhöhen
                  COMP  key_status, 0
                  RET   Z
                  FETCH s0, s_keycount_upper      ; gedrückte Tasten zählen
                  ADD   s0, $01
                  STORE s0, s_keycount_upper
                  RET   

inc_keys_lower: 
; bei gedrückter Taste Anzahl erhöhen
                  COMP  key_status, 0
                  RET   Z
                  FETCH s0, s_keycount_lower      ; gedrückte Tasten zählen
                  ADD   s0, $01
                  STORE s0, s_keycount_lower
                  RET   

set_key_upper: 
; Einsprung von Scanplatinen-Abfrage
; wird direkt aus get_key aufgerufen, getrennt für upper und lower
; key_status enthält aktuelle Tastenzustand der Taste von manual_select
                  LOAD  manual_select, 0          ; 0 = UPPER
                  COMP  key_mpx, 61               ; nur bis Note 60(+1) = C5
                  RET   NC
                  FETCH s0, s_splitpoint          ; ist ohne Split 0
                  COMP  key_mpx, s0
                  JUMP  NC, set_key_common        ; unterhalb Splitpoint?
                  FETCH manual_select, s_splitremap_upper; ggf. Remap
                  JUMP  set_key_common

set_key_lower: 
; Einsprung von Scanplatinen-Abfrage
; wird direkt aus get_key aufgerufen, getrennt für upper und lower
; key_status enthält aktuelle Tastenzustand der Taste von manual_select
                  LOAD  manual_select, 1          ; 1 = LOWER
                  COMP  key_mpx, 61               ; nur bis Note 60(+1) = C5
                  RET   NC
                  FETCH s0, s_splitpoint          ; ist ohne Split 0
                  COMP  key_mpx, s0
                  JUMP  NC, set_key_common        ; unterhalb Splitpoint?
                  FETCH manual_select, s_splitremap_lower; ggf. Remap
; JUMP      set_key_common

set_key_common: 
                  COMP  manual_select, 0
                  CALL  Z, inc_keys_upper
                  COMP  manual_select, 1
                  CALL  Z, inc_keys_lower
                  COMP  manual_select, 2
                  JUMP  Z, set_key_pedal          ; keine Manual-Taste
                  COMP  key_status, 1
                  JUMP  Z, mpx_slow               ; nur 1. Kontakt, slow inc
                  COMP  key_status, 2
                  JUMP  Z, mpx_fast               ; nur 2. Kontakt
                  COMP  key_status, 3
                  JUMP  Z, mpx_fast               ; 1. und 2. Kontakt
                  JUMP  mpx_off                   ; sonst OFF

set_key_pedal: 
; Einsprung von Scanplatinen-Abfrage
; wird direkt aus get_keystatus_pedal aufgerufen, getrennt für Pedal
; Tastenzustand prüfen und verteilen
                  LOAD  manual_select, 2          ; 2 = Bass
                  COMP  key_mpx, c_maxbasskeys + 1
                  RET   NC                        ; wenn key_mpx > c_maxbasskeys
; JUMP      mpx_pedal

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

; Tastenkontakte werden durch schreiben in das MPX-RAM eingeschaltet oder
; kurz auf "Noise" gesetzt.
; state-RAM enthalt Tastenzustand 0...15

mpx_pedal: 
; kleine Sonderbehandlung für Pedal, hat keine Dynamik und keine Noise-Bits:
; key_status enthält 0 (Taste aus) oder anderen Wert (Taste an),
; Falls sich neue Taste geändert hat, alte Taste löschen
; Vorher gespielte Pedaltaste löschen, Nummer der neue Pedaltaste merken
; manual_select enthält 2
                  COMP  key_status, 0
                  JUMP  Z, mpx_pedal_0            ; Taste ist aus wenn 0
                  LOAD  key_status, 1             ; nur zwei Zustände zulassen, hier ON
mpx_pedal_0: 
                  FETCH s0, s_pedal_on            ; Speicher für gedrückte Taste
                  OR    s0, key_status
                  STORE s0, s_pedal_on            ; kann innerhalb Pedalschleife '1' werden
; get_state/set_state hier nicht benötigt, weil kein Noise berücksichtigt wird
                  COMP  key_status, 0
                  JUMP  NZ, mpx_pedal_1           ; wenn Taste an
                  FETCH s1, s_pedal_lastkey
                  COMP  s1, key_mpx
; nicht abschalten wenn letzte gespielte Note
                  LOAD  s0, key_status
                  JUMP  NZ, mpx_set_contacts_s0   ; Taste in key_mpx, Zustand in s0
mpx_pedal_1: 
                  LOAD  s0, 1
                  STORE key_mpx, s_pedal_lastkey  ; letzte eingeschaltete Pedalnote
                  JUMP  mpx_set_contacts_s0       ; Taste in key_mpx, Zustand in s0


mpx_off: 
; Taste ist aus. Check ob erstmals aus
                  CALL  get_state                 ; letzten Zustand holen
                  COMP  s0, 0
                  RET   Z                         ; ist bereits aus

                  CALL  reset_noisetimer
                  CALL  get_state                 ; letzten Zustand holen
                  AND   s0, 15                    ; Noise wegmaskieren
                  SL0   s0                        ; Zustand halbieren
                  AND   s0, 7                     ; halber Pegel
                  LOAD  s1, 0                     ; Noise aus
                  JUMP  mpx_set_contacts

mpx_fast: 
; Taste ist nicht offen
; zweiter Kontakt geschlossen, voll gedrückt, fast inc to max.
                  CALL  start_noisetimer_fast     ; starten, falls noch in Ruhe
                  JUMP  mpx_noise_timeout

mpx_slow: 
; Taste ist nicht offen
; nur erster Kontakt geschlossen
                  CALL  start_noisetimer          ; ggf starten; wenn laufend, Timer-Wert in s0
; JUMP  mpx_noise_timeout

mpx_noise_timeout: 
; CALL  get_noisetimer
                  COMP  s0, $FF                   ; Timer-Wert noch in s0
                  JUMP  Z, mpx_fullon             ; Klick beendet?
                  COMP  s0, $FD                   ; Timer-Wert noch in s0
                  JUMP  Z, mpx_halfon             ; 2 ms vor Ende halber Steady-Pegel

                  FETCH s1, s_clicklen_fast       ; Timer-Startwert
                  COMP  s0, s1                    ; s0 - s1
                  JUMP  NC, mpx_fullnoise

mpx_halfnoise: 
                  LOAD  s0, 0                     ; half level
                  LOAD  s1, 7
                  JUMP  mpx_set_contacts

mpx_fullnoise: 
                  LOAD  s0, 8                     ; full level
                  LOAD  s1, 7                     ; all noise
                  JUMP  mpx_set_contacts

mpx_halfon: 
                  LOAD  s0, 7
                  LOAD  s1, 0
                  JUMP  mpx_set_contacts

mpx_fullon: 
                  STORE key_mpx, s_lastkey_on     ; für Split benötigt
                  LOAD  s0, 15                    ; full noise
                  LOAD  s1, 0
; jump  mpx_set_contacts

mpx_set_contacts: 
; Steady- (s0) und Noise-Anteil (s1) in mpx-RAM schreiben
; Tastennnummer in key_mpx
; Im Steady-Nibble s0: 0..7 Half Level, 8..15 Full Level (Bit 3)
; in ein Byte packen und zum MPX-RAM schicken
; in manual_select ist aktuell abgefragtes Manual
                  SL0   s1
                  SL0   s1
                  SL0   s1
                  SL0   s1
                  AND   s0, 15
                  OR    s0, s1
                  CALL  set_state
mpx_set_contacts_s0: 
; hier zu key_mpx ggf. Transponierwert addieren
; Tastennnummer in key_mpx, Zustand in s0
                  IN    s2, SPI_TRANSPOSE         ; hier als signed byte
                  ADD   s2, key_mpx
                  COMP  s2, 61
                  RET   NC
; separate Routine, um key_mpx nicht zu verändern
; (Transponierte) Note in s2
                  LOAD  page_select, c_page_enables
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page 0 = Tastenkontakte
                  OUT   s0, RAM_WRDATA            ; zu schreibende Daten in s0
                  OUT   s2, RAM_ADDR
                  LOAD  s1, manual_select         ; 0 oder 1
                  ADD   s1, c_strobe_mask
                  OUT   s0, ( s1 )                ; Upper oder Lower Strobe, $20 oder $21
                  RET   

; geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014

; Hilfsroutinen: Werte in Timer/Scratch-RAM lesen oder schreiben
; manual_select = 0 für Upper, manual_select = 1 für Lower Manual
start_noisetimer_fast: 
                  LOAD  page_select, c_page_noisetimer
                  CALL  get_ram
                  COMP  s0, 0
                  RET   NZ                        ; wenn bereits gestartet
                  IN    s0, RND_NUMBER            ; zufällige Länge
                  AND   s0, 1
                  FETCH s1, s_clicklen_fast       ; Timer-Startwert
                  JUMP  start_noisetimer_1

start_noisetimer: 
; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                  LOAD  page_select, c_page_noisetimer
                  CALL  get_ram
                  COMP  s0, 0
                  RET   NZ                        ; wenn bereits gestartet
                  IN    s0, RND_NUMBER            ; zufällige Länge
                  AND   s0, 3
                  FETCH s1, s_clicklen            ; Timer-Startwert
start_noisetimer_1: 
                  ADD   s0, s1
                  COMP  s0, $80                   ; auf Überlauf checken
                  JUMP  NC, set_noisetimer        ; wenn größer, gab es keinen Überlauf
                  LOAD  s0, $FE
set_noisetimer: 
                  LOAD  page_select, c_page_noisetimer
                  JUMP  set_ram

reset_noisetimer: 
                  LOAD  s0, 0
                  LOAD  page_select, c_page_noisetimer
                  JUMP  set_ram

get_noisetimer: 
                  LOAD  page_select, c_page_noisetimer
                  JUMP  get_ram

; ##############################################################################
; Dynamik- und Noise-Timer für beide Manuale aktualisieren
; geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014
; wird einmal pro Scan-Durchlauf aufgerufen, dauert ca. 52 µs
; ##############################################################################

update_timers: 
                  LOAD  page_select, c_page_dyntimer
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page Dynamik-Timer
                  LOAD  key_scanned, 0
                  CALL  update_timer_loop
                  LOAD  page_select, c_page_noisetimer
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page Noise-Timer
                  LOAD  key_scanned, 0

update_timer_loop: 
                  OUT   key_scanned, RAM_ADDR
                  ADD   key_scanned, 1
                  IN    s0, RD_UPPER
                  COMP  s0, 0
                  JUMP  Z, update_timer_done1     ; noch nicht gestartet
                  COMP  s0, 255
                  JUMP  Z, update_timer_done1     ; bereits abgelaufen
                  ADD   s0, 1
                  OUT   s0, RAM_WRDATA            ; zu schreibende Daten in s0
                  LOAD  s0, 0                     ; NOP
                  OUT   s0, UPPER_STROBE
                  LOAD  s0, 0                     ; NOP

update_timer_done1: 
                  IN    s0, RD_LOWER
                  COMP  s0, 0
                  JUMP  Z, update_timer_done2     ; noch nicht gestartet
                  COMP  s0, 255
                  JUMP  Z, update_timer_done2     ; bereits abgelaufen
                  ADD   s0, 1
                  OUT   s0, RAM_WRDATA            ; zu schreibende Daten in s0
                  LOAD  s0, 0                     ; NOP
                  OUT   s0, LOWER_STROBE

update_timer_done2: 
                  COMP  key_scanned, 64
                  JUMP  NZ, update_timer_loop
                  RET   

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

allnotesoff: 
; alle Töne, Flags und Timer löschen
                  LOAD  s0, 0
                  OUT   s0, RAM_WRDATA            ; Enables und Werte auf 0
                  OUT   s0, BASS_ENV
                  LOAD  key_scanned, 0
                  LOAD  page_select, 0
allnotesoff_loop: 
                  OUT   key_scanned, RAM_ADDR
                  OUT   page_select, RAM_PAGE
                  OUT   s0, UPPER_STROBE
                  OUT   s0, LOWER_STROBE
                  OUT   s0, PEDAL_STROBE

                  ADD   key_scanned, 1
                  COMP  key_scanned, 64           ; 64 Durchläufe?
                  JUMP  NZ, allnotesoff_loop
                  LOAD  key_scanned, 0
                  ADD   page_select, 1
                  COMP  page_select, 16           ; 16 Durchläufe?
                  JUMP  NZ, allnotesoff_loop
                  RET                             ; fertig

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

; Hüllkurvengenerator für Pedalsustain
; mit jedem Scan-Schleifendurchlauf alle 1 ms aktualisiert

pedal_envelope: 
; einmal vor jedem Scan-Durchlauf alle 1 ms aufgerufen
                  FETCH s0, s_pedal_env_msb
                  OUT   s0, BASS_ENV
                  IN    s1, SPI_PEDALTIME         ; 0..127
                  COMP  s1, 60                    ; Carry wird '1' wenn s1 kleiner 60
                  LOAD  s1, 0
                  SLA   s1                        ; shift carry in Bit 0
                  XOR   s1, 1
                  OUT   s1, BASS_BRIGHT

                  FETCH s0, s_pedal_on            ; Speicher für gedrückte Taste
                  COMP  s0, 0
                  JUMP  Z, pedal_envelope_dec
pedal_envelope_inc: 
; Pedal-Hüllkurve schnell 255 annähern
; s_pedal_env_msb enthält aktuellen Pedal-Pegel
                  FETCH s0, s_pedal_env_msb
                  COMP  s0, 255                   ; schon am Anschlag?
                  RET   Z
                  SL1   s0                        ; '1' einschieben, immer verdoppeln
                  STORE s0, s_pedal_env_msb
                  STORE s0, s_pedal_env_lsb
                  RET   

pedal_envelope_dec: 
; Pedal-Hüllkurve Null annähern
; s_pedal_env_msb enthält aktuellen Pedal-Pegel
                  COMP  s1, 1                     ; war noch BRIGHT-Switch
                  JUMP  Z, pedal_envelope_fastdec ; Original-Pedal ohne Sustain
                  FETCH s0, s_pedal_env_msb
                  COMP  s0, 0                     ; schon auf 0?
                  RET   Z
; Timer-Dekrement errechnen, semi-log. Abfall durch Einbeziehen des Zählerstands
                  IN    s1, SPI_PEDALTIME
                  SL0   s1                        ; 4..126
                  SL0   s1                        ; 8..252
                  SUB   s1, 8
                  SL0   s1
                  LOAD  s2, 0
                  SLA   s2                        ; Carry in s2 Bit 0
                  SR0   s0                        ; Level MSB, größer am Anfang, halber Wert
                  ADD   s1, s0                    ; 
                  ADDC  s2, 0

                  FETCH s0, s_pedal_env_lsb
                  SUB   s0, s1
                  STORE s0, s_pedal_env_lsb
                  FETCH s0, s_pedal_env_msb
                  SUBC  s0, s2
                  STORE s0, s_pedal_env_msb
                  JUMP  C, pedal_envelope_limit
                  RET   

pedal_envelope_limit: 
                  LOAD  s0, 0
                  STORE s0, s_pedal_env_lsb
                  STORE s0, s_pedal_env_msb
                  RET   

pedal_envelope_fastdec: 
                  FETCH s0, s_pedal_env_msb
                  COMP  s0, 0
                  RET   Z
                  SR0   s0                        ; '0' einschieben, immer halbieren
                  STORE s0, s_pedal_env_msb
                  STORE s0, s_pedal_env_lsb
                  RET   

; ##############################################################################
; ###################### NEUE MPX-ROUTINEN FÜR TIMER ###########################
; ##############################################################################


; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

start_dyntimer: 
; Dynamik-Timer der aktuellen Taste starten, wenn nicht bereits geschehen
                  LOAD  page_select, c_page_dyntimer
                  CALL  get_ram
                  COMP  s0, 0
                  RET   NZ                        ; wenn bereits gestartet
                  LOAD  s0, 1                     ; Timer starten, zählt aufwärts
                  JUMP  set_ram

reset_dyntimer: 
                  LOAD  s0, 0                     ; Timer stoppen
                  LOAD  page_select, c_page_dyntimer
                  JUMP  set_ram

get_dyntimer: 
                  LOAD  page_select, c_page_dyntimer
                  JUMP  get_ram

; # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

; Werte in MPX/Scratch-RAM setzen mit aktuellem manual_select und key_mpx

set_midiflag: 
                  LOAD  page_select, c_page_midiflags
                  JUMP  set_ram

set_state: 
                  LOAD  page_select, c_page_state
; JUMP  set_ram

set_ram: 
; zu schreibende Daten in s0, RAM_PAGE muss gesetzt sein
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page 0 = Tastenkontakte
                  OUT   s0, RAM_WRDATA            ; zu schreibende Daten in s0
                  OUT   key_mpx, RAM_ADDR
                  LOAD  s1, manual_select         ; 0 oder 1
                  ADD   s1, c_strobe_mask
                  OUT   s0, ( s1 )                ; Upper oder Lower Strobe, $20 oder $21
                  RET   

get_midircv: 
                  LOAD  page_select, c_page_midirx
                  JUMP  get_ram

get_midiflag: 
                  LOAD  page_select, c_page_midiflags
                  JUMP  get_ram

get_state: 
                  LOAD  page_select, c_page_state
; JUMP  get_ram

get_ram: 
; gelesene Daten später in s0
                  OUT   page_select, RAM_PAGE     ; MPX-RAM Page 0 = Tastenkontakte
                  OUT   key_mpx, RAM_ADDR
                  LOAD  s1, manual_select         ; 0 oder 1
                  ADD   s1, c_read_mask
                  IN    s0, ( s1 )                ; Upper, Lower oder Pedal Read
                  RET                             ; gelesene Daten in s0

; bis hier geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014

; ##############################################################################
; ##############################################################################
; ##############################################################################


; MIDI-Routinen für Scan-Events bei Keyboard-Abfrage
; sollte bei allen Scan-Boards gleich sein
midi_local_manuals: 
                  COMP  key_status, 0
                  JUMP  Z, midi_local_off
                  COMP  key_status, 1
                  JUMP  Z, midi_local_start       ; MIDI Dyn-Timer dieser Taste starten, sofern noch nicht geschehen
                  COMP  key_status, 2             ; verschmutzter Kontakt?
                  JUMP  Z, midi_local_on_nodyn    ; dann Sonderbehandlung
                  JUMP  midi_local_on

midi_local_pedal: 
                  COMP  key_status, 0
                  JUMP  Z, midi_local_off
                  JUMP  midi_local_on_nodyn

midi_local_start: 
                  CALL  get_midiflag              ; bereits gesendet? Dann nichts machen
                  COMP  s0, $FF
                  RET   Z                         ; schon passiert
; MIDI Timer dieser Taste starten, sofern noch nicht geschehen
                  CALL  start_dyntimer
; in s0 ist vom Vergleich noch der vorherige Wert des Dyn-Timers oder 1
                  COMP  s0, $FF                   ; Dynamik-Timer evt. schon abgelaufen, dh. 255?
                  RET   NZ                        ; wenn noch nicht abgelaufen, zurück
; Timer ist abgelaufen, evt. 2. Schließer schmutzig oder Taste sehr langsam gedrückt
                  LOAD  s1, $01                   ; minimale Dynamik vorbereiten
                  JUMP  midi_local_on_s1          ; und weiter mit Dynamik in s1

midi_local_on_nodyn: 
; Taste 1. Kontakt schmutzig. Mittlere Dynamik senden, falls nicht schon geschehen
                  CALL  get_midiflag              ; bereits gesendet? Dann nichts machen
                  COMP  s0, $FF
                  RET   Z                         ; schon passiert
                  LOAD  s1, $40                   ; mittlere Dynamik vorbereiten
                  JUMP  midi_local_on_s1          ; und weiter mit Dynamik in s1

midi_local_on: 
; MIDI-Check - muss ON gesendet werden?
                  CALL  get_midiflag              ; bereits gesendet? Dann nichts machen
                  COMP  s0, $FF
                  RET   Z                         ; schon passiert

; Dynamik-Kurve mit zwei Steigungen, ab $C0 Eingangswert doppelt so steil
                  CALL  get_dyntimer              ; Dynamik-Timer 1..255
                  LOAD  s1, $FF
                  SUB   s1, s0                    ; (255 - Timerstand) in s1
                  COMP  s1, $C0
                  JUMP  NC, midi_local_on_scale1
                  SR0   s1                        ; /2 -> 0..127
                  SR0   s1                        ; /2 -> 0..127
                  COMP  s1, $02
                  JUMP  NC, midi_local_on_scale0  ; wenn kleiner $02
                  LOAD  s1, $02                   ; minimaler MIDI-dyn-Wert
midi_local_on_scale0: 
                  JUMP  midi_local_on_scaled
midi_local_on_scale1: 
                  LOAD  s0, s1
                  SR0   s1                        ; /2 -> 0..127
                  SR0   s1                        ; /2 -> 0..127
                  SUB   s0, $C0
                  ADD   s1, s0
; Da während eines Schleifendurchlaufs der DynTimer weiterläuft und immer einen
; Mindestwert erreicht, wird hier ein kleiner Offset hinzuaddiert.
; Durch Ausprobieren bei schnellstem Tastenanschlag ermittelt, so dass
; beim Dynamik-Byte Maximalwert $7F knapp erreicht wird.
midi_local_on_scaled: 
                  ADD   s1, c_midi_minofs
                  COMP  s1, $7F
                  JUMP  C, midi_local_on_s1       ; wenn kleiner $7F
                  LOAD  s1, $7F

midi_local_on_s1: 
                  STORE s1, s_midi_localdyn
                  LOAD  s0, $FF
                  CALL  set_midiflag              ; Flag: ON ist gesendet
                  JUMP  midi_local_out

midi_local_off: 
; MIDI-Check - muss OFF gesendet werden?
                  CALL  get_midiflag              ; bereits gesendet? Dann nichts machen
                  COMP  s0, 0
                  RET   Z                         ; OFF ist bereits gesendet
                  CALL  reset_dyntimer
                  LOAD  s0, $00
                  STORE s0, s_midi_localdyn
                  CALL  set_midiflag              ; Flag: OFF ist gesendet
; JUMP      midi_local_out                ; und senden

; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge'	// MIDI Option 2
; 'RcvSndMgNoCC'	// MIDI Option 3

midi_local_out: 
; Manual in manual_select, On/Off-Dynamik in s_midi_localdyn
                  FETCH s0, s_midiopt
                  COMP  s0, 0                     ; nur senden, wenn nicht Thru
                  RET   Z
                  CALL  midi_waitbuf
                  FETCH s0, s_midich              ; eingestellter Kanal
                  LOAD  s1, manual_select         ; Manual-Nummer addieren
                  ADD   s0, s1
                  OR    s0, $90
                  OUT   s0, MIDI_TX
                  FETCH s0, s_midi_localkey
                  ADD   s0, c_midikeyoffset
                  AND   s0, $7F
                  OUT   s0, MIDI_TX
                  FETCH s0, s_midi_localdyn       ; gemessene Dynamik
                  OUT   s0, MIDI_TX
                  RET   

midi_waitbuf: 
                  IN    s0, TX_STATUS             ; half full?
                  AND   s0, 1
                  COMP  s0, 1
                  JUMP  Z, midi_waitbuf           ; auf Buffer-Leerung warten
                  RET   

midi_activesensing: 
                  FETCH s0, s_midiopt
                  COMP  s0, 0                     ; nur senden, wenn nicht Thru
                  RET   Z
                  CALL  midi_waitbuf
                  LOAD  s0, $FE
                  OUT   s0, MIDI_TX
                  RET   

; ##############################################################################
; MIDI-Subroutinen für MIDI-Empfang
; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge',	// MIDI Option 2
; 'RcvSndMgNoCC'	// MIDI Option 3
; ##############################################################################

midi_resend: 
; empfangenen Datensatz 1 bis 3 Bytes gleich wieder senden, für Merge
                  CALL  midi_waitbuf
                  FETCH s0, s_midi_cmd
                  OUT   s0, MIDI_TX
                  FETCH s0, s_midi_count
                  COMP  s0, 0
                  RET   Z
                  FETCH s0, s_midi_byte1
                  OUT   s0, MIDI_TX
                  FETCH s0, s_midi_count
                  COMP  s0, 1
                  RET   Z
                  FETCH s0, s_midi_byte2
                  OUT   s0, MIDI_TX
                  RET   

; ##############################################################################

midi_dispatch_avr: 

                  RET   

midi_dispatch: 
; Dispatcher stellt fest, ob und was es zu tun gibt
; wird regelmäßig aus Hauptschleife aufgerufen
                  COMP  i_rxflag, 0
                  RET   Z                         ; wenn kein Flag gesetzt
                  LOAD  i_rxflag, 0               ; Rx-Flag löschen
                  FETCH s0, s_midi_irq_cmd        ; von IRQ gesetzte Bytes
                  STORE s0, s_midi_cmd
                  FETCH s0, s_midi_irq_byte1
                  STORE s0, s_midi_byte1
                  FETCH s0, s_midi_irq_byte2
                  STORE s0, s_midi_byte2
                  FETCH s0, s_midi_irq_count
                  STORE s0, s_midi_count

midi_dispatch_0: 
; MIDI-Datensatz vollständig, dekodieren und Taste beschreiben
                  FETCH s0, s_midiopt
                  COMP  s0, 2                     ; >=2, Merge oder NoCC?
                  CALL  NC, midi_resend

                  FETCH s1, s_midi_cmd
                  AND   s1, $0F                   ; Kanal isolieren und in s1
                  FETCH s0, s_midi_cmd
                  AND   s0, $F0                   ; Befehl isolieren
                  STORE s0, s_midi_cmd_masked

                  FETCH s2, s_midi_byte2          ; Dynamik dieser Taste
                  LOAD  manual_select, 0          ; Default
                  FETCH s0, s_midich              ; eingestellter Kanal
                  COMP  s1, s0                    ; eingestellter gleich empfangener Kanal?
                  JUMP  Z, midi_dispatch_onoff    ; mit manual_select = 0, upper
                  ADD   s0, 1
                  COMP  s1, s0                    ; eingestellter Kanal +1?
                  JUMP  Z, midi_dispatch_onoff_lower
                  ADD   s0, 1
                  COMP  s1, s0                    ; eingestellter Kanal +2?
                  RET   NZ                        ; Kanal nicht für uns, verwerfen

midi_dispatch_onoff_pedal: 
; MIDI-NoteOn/NoteOff-Befehle
                  LOAD  manual_select, 2
                  COMP  s2, 0                     ; default Dynamik 0
                  JUMP  Z, midi_dispatch_onoff
                  LOAD  s2, 1                     ; Tastendynamik 1 statt irgendwas
                  JUMP  midi_dispatch_onoff       ; nur einbittig speichern!

midi_dispatch_onoff_lower: 
; MIDI-NoteOn/NoteOff-Befehle
                  LOAD  manual_select, 1
; JUMP  midi_dispatch_onoff

midi_dispatch_onoff: 
; MIDI-NoteOn/NoteOff-Befehle, Dynamik bereits in s2, Manual in manual_select
                  FETCH s0, s_midi_cmd_masked
                  COMP  s0, $90
                  JUMP  Z, midi_dispatch_set_ram
                  COMP  s0, $80
                  JUMP  NZ, midi_dispatch_rest
                  LOAD  s2, 0                     ; MIDI-Befehl Taste OFF, Dynamik 0

midi_dispatch_set_ram: 
; jetzt Notenwert und Dynamik abspeichern, Dynamik noch in s2
; zu schreibende Daten in s0, RAM_PAGE muss gesetzt sein
                  FETCH s1, s_midi_byte1          ; MIDI-Key in s1
                  SUB   s1, c_midikeyoffset       ; Tastennummer ermitteln
                  COMP  s1, 61
                  RET   NC                        ; nicht schreiben, ist außerhalb 5 Okt.
                  OUT   s2, RAM_WRDATA            ; zu schreibende Dynamik in s2
                  OUT   s1, RAM_ADDR              ; Tastennummer in s1
                  LOAD  s0, c_page_midirx
                  OUT   s0, RAM_PAGE              ; MPX-RAM Page
                  LOAD  s0, manual_select         ; 0 oder 1
                  ADD   s0, c_strobe_mask
                  OUT   s0, ( s0 )                ; Upper, Lower oder Pedal Strobe
                  RET   

midi_dispatch_rest: 
; Program Change und Controller? Dann an AVR
                  COMP  s0, $C0
                  JUMP  Z, midi_pchange
                  COMP  s0, $B0
                  RET   NZ                        ; alles andere unberücksichtigt
midi_cchange: 
; bei Controller Change auf ALL NOTES OFF prüfen, dann weiter wie Program Change
                  FETCH s0, s_midi_byte1
                  COMP  s0, 123                   ; All Notes OFF?
; JUMP      Z, allnotesoff_manual      ; falls nicht, weiter mit AVR-IRQ

midi_pchange: 
; auf Program Change hin nur einen AVR-IRQ auslösen; MIDI-Daten an SPI
                  FETCH s0, s_midi_cmd
                  OUT   s0, MIDI_CMD
                  FETCH s0, s_midi_byte1
                  OUT   s0, MIDI_DB1
                  FETCH s0, s_midi_byte2
                  OUT   s0, MIDI_DB2
                  LOAD  s0, 1                     ; pos. Flanke an MIDI-FIFO
                  OUT   s0, MIDI_STR
                  LOAD  s0, 0
                  OUT   s0, MIDI_STR
                  RET   

allnotesoff_manual: 
; feststellen, für welchen Kanal gesendet und alle Tasten löschen
allnotesoff_upper: 
; noch nicht implementiert
                  RET   
allnotesoff_lower: 
; noch nicht implementiert
                  RET   
allnotesoff_pedal: 
; noch nicht implementiert
                  RET   

; ##############################################################################
; Splitmode setzen:
; 0 = PedalToLower,
; 1 = LowerToUpper und
; 2 = PedalToUpper
; ##############################################################################

set_splitpoint: 
; Split-Funktion wurde seit letztem Durchlauf von OFF auf ON geändert.
                  CALL  allnotesoff

                  FETCH s0, s_split_on
                  COMP  s0, 0
                  JUMP  Z, split_off

; Feststellen, ob Keyboard-Tasten gedrückt wurden, dann diese als
; Splitpoint nehmen. Falls keine gedrückt, letzten Split
                  FETCH s0, s_keycount_upper
                  FETCH s1, s_keycount_lower
                  OR    s0, s1
                  COMP  s0, 0
                  JUMP  NZ, split_custom          ; Tasten gedrückt, neuer Splitmode

; gedrückte Taste als Splitpoint. Springt danach zu split_on
; wenn gar keine Keyboard-Taste gedrückt, weiter mit alten Werten, sofern initialisiert
                  JUMP  split_restore_old

split_custom: 
                  FETCH s1, s_lastkey_on
                  STORE s1, s_splitpoint
                  FETCH s0, s_keycount_upper
                  COMP  s0, 0
                  JUMP  Z, split_pedal_to_lower   ; Upper 0? Dann Split auf Lower
                  COMP  s0, 1                     ; Nur eine Taste gedrückt? Dann Lower to Upper
                  JUMP  Z, split_lower_to_upper   ; Wenn nur eine Taste, Lower to Upper
                  LOAD  s0, 2                     ; Mehr als eine Taste, Bass to Upper
                  JUMP  split_pedal_to_upper

split_restore_old: 
; 0 = PedalToLower, 1 = LowerToUpper und  2 = PedalToUpper
                  FETCH s0, s_splitmode_old
                  COMP  s0, 1
                  JUMP  Z, split_lower_to_upper
                  COMP  s0, 2
                  JUMP  Z, split_pedal_to_upper
; JUMP  split_pedal_to_lower           ; wenn 0

; Wenn bei der Tastenabfrage key_mpx < Splitpoint,
; wird manual_select auf s_splitremap gesetzt
split_pedal_to_lower:                             ; split_mode 0
                  STORE s0, s_splitmode_old
                  LOAD  s0, 2                     ; Pedal
                  STORE s0, s_splitremap_lower
                  LOAD  s0, 0                     ; Upper
                  STORE s0, s_splitremap_upper
                  RET   
split_lower_to_upper:                             ; split_mode 1
                  STORE s0, s_splitmode_old
                  LOAD  s0, 2
                  STORE s0, s_splitremap_lower
                  LOAD  s0, 1
                  STORE s0, s_splitremap_upper
                  RET   
split_pedal_to_upper:                             ; split_mode 2
                  STORE s0, s_splitmode_old
                  LOAD  s0, 1
                  STORE s0, s_splitremap_lower
                  LOAD  s0, 2
                  STORE s0, s_splitremap_upper
                  RET   
split_off: 
                  LOAD  s0, 1
                  STORE s0, s_splitremap_lower
                  LOAD  s0, 0
                  STORE s0, s_splitremap_upper
                  RET   

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; +++++++++++   Interrupt-Service-Handler für SPI und MIDI-Empfang  ++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

is_any_IRQ: 
; IRQ ausgelöst durch kcuart
                  CALL  is_MIDI_IRQ
                  RETI  ENABLE

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

is_MIDI_IRQ: 
; MIDI Daten wurden empfangen
; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
; 'ReceiveThru'	,	// MIDI Option 0 - nichts Eigenes senden!
; 'ReceiveSend'	,	// MIDI Option 1
; 'RcvSendMerge'	,	// MIDI Option 2
; 'RcvSndMgNoCC'		// MIDI Option 3
                  IN    i_acc0, MIDI_RX
                  FETCH i_acc1, s_midiopt
                  COMP  i_acc1, 0                 ; wenn Thru, weitergeben
                  JUMP  NZ, is_not_thru           ; Ergebnis vom Vergleich!
; wenn Thru, Byte unbehandelt weitergeben, aber selbst verwenden. Es wird nichts Eigenes gesendet.
                  OUT   i_acc0, MIDI_TX

is_not_thru: 
                  COMP  i_acc0, $FE               ; Active Sensing verwerfen, kann immer kommen
                  RET   Z
                  COMP  i_acc0, $F0               ; Sysex usw. ab $F0 verwerfen
                  JUMP  NC, is_syscontrol

                  TEST  i_acc0, 128
                  JUMP  Z, is_databyte
                  LOAD  i_syscmdflag, $00         ; ist kein Active Sensing usw.
                  LOAD  i_datacount, 0
                  STORE i_acc0, s_midi_irq_cmd
                  RET   
is_databyte: 
                  COMP  i_syscmdflag, $00
                  RET   NZ
                  ADD   i_datacount, 1
                  COMP  i_datacount, 2
                  JUMP  Z, is_databyte2

; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
; Datensatz ist mit einem Datenbyte vollständig!
                  FETCH i_acc1, s_midi_irq_cmd
                  AND   i_acc1, $F0               ; Kanal ausmaskieren
                  COMP  i_acc1, $C0               ; program change
                  JUMP  Z, is_singledatabyte
                  COMP  i_acc1, $D0               ; channel pressure
                  JUMP  Z, is_singledatabyte

is_databyte1: 
                  STORE i_acc0, s_midi_irq_byte1
                  RET   
; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
is_singledatabyte: 
                  STORE i_acc0, s_midi_irq_byte1
is_databyte2: 
                  STORE i_acc0, s_midi_irq_byte2
                  STORE i_datacount, s_midi_irq_count; Anzahl empfangener Datenbytes
                  LOAD  i_datacount, 0
                  LOAD  i_rxflag, $FF             ; jetzt vollständig, Flag setzen
                  RET   
is_syscontrol: 
                  LOAD  i_syscmdflag, $FF
                  RET   

                  ORG   $3FF
                  JUMP  is_any_IRQ

